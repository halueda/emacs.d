[
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/markdown/",
	"title": "7.1. markdown-mode",
	"tags": [],
	"description": "",
	"content": "5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。\n(leaf markdown-mode :ensure t :mode (\u0026#34;\\\\.md\\\\\u0026#39;\u0026#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-code-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。\nhttps://github.com/shime/emacs-livedown\nnpmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。\n$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。\n(leaf emacs-livedown :el-get shime/emacs-livedown :bind ((\u0026#34;C-c C-c p\u0026#34; . livedown-preview) (\u0026#34;C-c C-c k\u0026#34; . livedown-kill))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/auto-save-buffer/",
	"title": "9.1. auto-save-buffer-enhanced",
	"tags": [],
	"description": "",
	"content": " auto-save-buffer-enhanced は、ファイルの自動保存機能を提供します。 kentaro/auto-save-buffer-enhanced.el: Provide file autosave in Emacs  ;; auto-save-buffers (leaf auto-save-buffers-enhanced :ensure t :custom `((auto-save-buffers-enhanced-exclude-regexps . \u0026#39;(\u0026#34;^/ssh:\u0026#34; \u0026#34;^/scp:\u0026#34; \u0026#34;/sudo:\u0026#34;)) (auto-save-buffers-enhanced-quiet-save-p . t) ;; Disable to prevent freeze in tramp-mode (auto-save-buffers-enhanced-include-only-checkout-path . nil)) :config (auto-save-buffers-enhanced t)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/undo-fu/",
	"title": "9.2. undo-fua",
	"tags": [],
	"description": "",
	"content": "8.3. [undo-fu] シンプルな undo/redo を提供 undo-fu はシンプルな undo/redo 機能を提供してくれるやつです。\n昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えました。\n(leaf undo-fu :ensure t :bind ((\u0026#34;C-_\u0026#34; . undo-fu-only-undo) (\u0026#34;C-/\u0026#34; . undo-fu-only-redo))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/",
	"title": "起動設定",
	"tags": [],
	"description": "",
	"content": "Emacs の起動設定に関わる部分をここでは設定している\n Emacs-27導入にあわせて early-init.el を設定しました。 ブートシーケンスは以下のとおり。  1. early-init.el の読み込み 2. init.el の読み込み 3. inits/ のファイル群を読み込み （init-loader 使用）  eary-init.el を使う 早期設定ファイルの設定 speed up startup Magic File Name を一時的に無効にして起動時間を短縮するためのおまじない(^^) leaf.el を使う 設定ファイルを明示的に書くためのパッケージです。 init-loader.el を使う 設定ファイル群のローダーです。 test.el 最小限の emacs を起動させるための設定 dashboard dashboardを起動初期画面にする  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/dimmer/",
	"title": "5.2. dimmer-mode",
	"tags": [],
	"description": "",
	"content": " dimmer.el は、現在のバッファ以外の輝度を落とす機能を実現するためのパッケージです。  takaxp.github.io の設定をそのままパクリました。 ON/OFF できるのが快適です。\n(leaf dimmer :ensure t :chord (\u0026#34;..\u0026#34; . my:toggle-dimmer) :config (defvar my:dimmer-mode 1) (setq dimmer-buffer-exclusion-regexps \u0026#39;(\u0026#34;^ \\\\*which-key\\\\|^ \\\\*LV\\\\|^ \\\\*.*posframe.*buffer.*\\\\*$\u0026#34;)) (setq dimmer-fraction 0.6) (defun my:toggle-dimmer () (interactive) (unless (one-window-p) (if (setq my:dimmer-mode (not my:dimmer-mode)) (dimmer-on) (dimmer-off)))) (defun dimmer-off () (dimmer-process-all) (dimmer-mode -1)) (defun dimmer-on () (when my:dimmer-mode (dimmer-mode 1) (dimmer-process-all)))) Sprit-window と連携させる dimmer-mode を global に設定すると多くのシーンでDisable対策の設定が必要になり面倒です。\n下記の通り発想転換すれば呪縛から逃れることができます。\n 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((\u0026#34;C-q\u0026#34; . other-window-or-split) (\u0026#34;C-x 3\u0026#34; . my:split-window-right) (\u0026#34;C-x 2\u0026#34; . my:split-window-below) (\u0026#34;C-x 1\u0026#34; . my:delete-other-windows) (\u0026#34;C-x 0\u0026#34; . my:delete-window) (\u0026#34;\u0026lt;C-return\u0026gt;\u0026#34; . window-swap-states)) :init (defun other-window-or-split () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (defun my:split-window-right () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (split-window-right) (follow-mode 1) (dimmer-mode 1)) (defun my:split-window-below () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (split-window-below) (follow-mode 1) (dimmer-mode 1)) (defun my:delete-window () \u0026#34;With turn off dimmer.\u0026#34; (interactive) (delete-window) (when (one-window-p) (dimmer-mode -1))) (defun my:delete-other-windows () \u0026#34;With turn off dimmer.\u0026#34; (interactive) (delete-other-windows) (dimmer-mode -1)) (defun kill-other-buffers () \u0026#34;Kill all other buffers.\u0026#34; (interactive) (mapc \u0026#39;kill-buffer (delq (current-buffer) (buffer-list))) (message \u0026#34;killl-other-buffers!\u0026#34;)))  画面分割時に follow-mode もonにしておくと行数の多いバッファーを見るのに便利です。  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/view/",
	"title": "7.2. veiw-mode",
	"tags": [],
	"description": "",
	"content": "5.3. viewモード 特定の拡張子に対して常に view モードで開きたいときやgzされた elisp ソースを見るときに view-mode を使います。\n下記の設定では、my:auto-view-dirs に追加したディレクトリのファイルを開くと view-mode が常に有効になります．\n(leaf view :hook (find-file-hook . my:auto-view) (server-visit-hook . my:unlock-view-mode) :chord (\u0026#34;::\u0026#34; . view-mode) :bind (:view-mode-map (\u0026#34;h\u0026#34; . backward-char) (\u0026#34;l\u0026#34; . forward-char) (\u0026#34;a\u0026#34; . beginning-of-buffer) (\u0026#34;e\u0026#34; . end-of-buffer) (\u0026#34;w\u0026#34; . forward-word) (\u0026#34;b\u0026#34; . scroll-down) (\u0026#34;c\u0026#34; . kill-ring-save) (\u0026#34;r\u0026#34; . xref-find-references) (\u0026#34;RET\u0026#34; . xref-find-definitions) (\u0026#34;x\u0026#34; . my:view-del-char) (\u0026#34;y\u0026#34; . my:view-yank) (\u0026#34;d\u0026#34; . my:view-kill-region) (\u0026#34;u\u0026#34; . my:view-undo) (\u0026#34;m\u0026#34; . magit-status) (\u0026#34;g\u0026#34; . my:google) (\u0026#34;s\u0026#34; . swiper-region) (\u0026#34;%\u0026#34; . my:jump-brace) (\u0026#34;@\u0026#34; . counsel-mark-ring) (\u0026#34;n\u0026#34; . my:org-view-next-heading) (\u0026#34;p\u0026#34; . my:org-view-previous-heading) (\u0026#34;o\u0026#34; . other-window-or-split) (\u0026#34;G\u0026#34; . end-of-buffer) (\u0026#34;0\u0026#34; . my:delete-window) (\u0026#34;1\u0026#34; . my:delete-other-windows) (\u0026#34;2\u0026#34; . my:split-window-below) (\u0026#34;+\u0026#34; . text-scale-increase) (\u0026#34;-\u0026#34; . text-scale-decrease) (\u0026#34;/\u0026#34; . (lambda ()(interactive)(text-scale-set 0))) (\u0026#34;_\u0026#34; . kill-other-buffers) (\u0026#34;:\u0026#34; . View-exit-and-edit) (\u0026#34;i\u0026#34; . View-exit-and-edit) (\u0026#34;]\u0026#34; . winner-undo) (\u0026#34;[\u0026#34; . winner-redo) (\u0026#34;.\u0026#34; . hydra-view/body)) :init ;; Specific extension / directory (defvar my:auto-view-regexp \u0026#34;\\\\.php\\\\|\\\\.pl\\\\|\\\\.el.gz?\\\\|\\\\.tar.gz?\\\\\u0026#39;\u0026#34;) ;; Specific directory (defvar my:auto-view-dirs nil) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;~/src/\u0026#34;) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;~/Dropbox/GH/\u0026#34;) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;/scp:xsrv:/home/minorugh/\u0026#34;) (defun my:auto-view () \u0026#34;Open a file with view mode.\u0026#34; (when (file-exists-p buffer-file-name) (when (and my:auto-view-regexp (string-match my:auto-view-regexp buffer-file-name)) (view-mode 1)) (dolist (dir my:auto-view-dirs) (when (eq 0 (string-match (expand-file-name dir) buffer-file-name)) (view-mode 1))))) (defun my:unlock-view-mode () \u0026#34;Unlock view mode with git commit.\u0026#34; (when (string-match \u0026#34;COMMIT_EDITMSG\u0026#34; buffer-file-name) (view-mode 0)))) view-mode のときにモードラインの色を変えるのは viewer.el を使うと設定が簡単です。\n;; Change-modeline-color (leaf viewer :ensure t :hook (view-mode-hook . viewer-change-modeline-color-setup) :custom `((viewer-modeline-color-view . \u0026#34;#852941\u0026#34;) (viewer-modeline-color-unwritable . \u0026#34;#2F6828\u0026#34;))) view-mode からでも簡単な編集ができるように vim like なコマンドをいくつか作りました。\n(with-eval-after-load \u0026#39;view ;; save-buffer no message (defun my:save-buffer () \u0026#34;With clear Wrote message.\u0026#34; (interactive) (save-buffer) (message nil)) ;; Like as \u0026#39;x\u0026#39; of vim (defun my:view-del-char () \u0026#34;Delete charactor in view mode.\u0026#34; (interactive) (view-mode 0) (delete-char 1) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;dd\u0026#39; of vim (defun my:view-kill-region () \u0026#34;If the region is active, to kill region. If the region is inactive, to kill whole line.\u0026#34; (interactive) (view-mode 0) (if (use-region-p) (kill-region (region-beginning) (region-end)) (kill-whole-line)) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;u\u0026#39; of vim (defun my:view-undo () \u0026#34;Undo in view mode.\u0026#34; (interactive) (view-mode 0) (undo) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;y\u0026#39; of vim (defun my:view-yank () \u0026#34;Yank in view mode.\u0026#34; (interactive) (view-mode 0) (yank) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;%\u0026#39; of vim (defun my:jump-brace () \u0026#34;Jump to the corresponding parenthesis.\u0026#34; (interactive) (let ((c (following-char)) (p (preceding-char))) (if (eq (char-syntax c) 40) (forward-list) (if (eq (char-syntax p) 41) (backward-list) (backward-up-list))))) (defun my:org-view-next-heading () \u0026#34;Org-view-next-heading.\u0026#34; (interactive) (if (and (derived-mode-p \u0026#39;org-mode) (org-at-heading-p)) (org-next-visible-heading 1) (next-line))) (defun my:org-view-previous-heading () \u0026#34;Org-view-previous-heading.\u0026#34; (interactive) (if (and (derived-mode-p \u0026#39;org-mode) (org-at-heading-p)) (org-previous-visible-heading 1) (previous-line)))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/",
	"title": "コア設定",
	"tags": [],
	"description": "",
	"content": "Emacs の基本動作に関わる部分をここでは設定している\n Language / Encode 言語と文字コードの設定 Mozc 日本語入力の設定 Server サーバー機能を使う設定 exec-path-from-shell 設定をシェルから継承する uniquify 同じバッファ名が開かれた場合に区別する global-keibind グローバルキーバインドのカスタマイズ設定  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/scrool-other-window/",
	"title": "5.3. scrool-other-Window",
	"tags": [],
	"description": "",
	"content": "Scrool-other-Window は、deactive なwindowをスクロールさせるための設定です。\n一画面のとき \u0026lt;next\u0026gt; / \u0026lt;prior\u0026gt; は、PgUp / PgDn として使うが、画面分割のときだけ other-Window に対応させている。 標準機能の C-v: scroll-uo-command / M-v: scroll-down-command を使い分ければ快適に二画面同時閲覧が可能となる。\n(leaf *my:scroll-other-window :bind ((\u0026#34;\u0026lt;next\u0026gt;\u0026#34; . my:scroll-other-window) (\u0026#34;\u0026lt;prior\u0026gt;\u0026#34; . my:scroll-other-window-down)) :init (defun my:scroll-other-window () \u0026#34;If there are two windows, `scroll-other-window\u0026#39;.\u0026#34; (interactive) (when (one-window-p) (scroll-up)) (scroll-other-window)) (defun my:scroll-other-window-down () \u0026#34;If there are two windows, `scroll-other-window-down\u0026#39;.\u0026#34; (interactive) (when (one-window-p) (scroll-down)) (scroll-other-window-down))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/all-the-icons/",
	"title": "7.3. all-the-icons",
	"tags": [],
	"description": "",
	"content": "all-the-icons.el を使うとバッファ内やモードライン、ミニバッファでアイコンを表示できるようになります。\n domtronn/all-the-icons.el: A utility package to collect various Icon Fonts and propertize them within Emacs.  初めて使うときはパッケージを使えるようにした後、M-x all-the-icons-install-fonts すると自動的にフォントがインストールされます。以下の設定では自動化しています。\n(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) (lisp-interaction-mode-hook dired-mode-hook). my:disable-modes) :bind (\u0026#34;\u0026lt;f9\u0026gt;\u0026#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () \u0026#34;Disable modes in scrtch buffer.\u0026#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0))) all-the-icons-dired dired でファイルのアイコンを表示します。\n Emacs27以降、MELPA版は白色にしか表示されないので jtbm37/all-the-icons-dired をel-getでインストールしています。  (leaf all-the-icons-dired :el-get jtbm37/all-the-icons-dired :after doom-modeline :hook (dired-mode-hook . all-the-icons-dired-mode)) all-the-icons-ivy-rich ivy-mode でアイコン表示をします。\n(leaf all-the-icons-ivy-rich :ensure t :hook (after-init-hook . all-the-icons-ivy-rich-mode)) all-the-icons-ibuffer ibuffer-mode でアイコン表示をします。\n(leaf all-the-icons-ibuffer :ensure t :hook (ibuffer-mode-hook . all-the-icons-ibuffer-mode)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/linespacing/",
	"title": "7.3. line-spacing",
	"tags": [],
	"description": "",
	"content": "12.4 行間を制御する line-spacing 行間を制御する変数です。バッファローカルな変数なので、ミニバッファも含めて、各バッファの行間を個別に制御できます。\n@takaxpさんのブログ記事 のによると、global で 0.3 以下に設定すると nil に戻せないという不具合があるとのことなので、Tipsをパクって以下のように設定をしました。\n(defun my:linespacing () (unless (minibufferp) (setq-local line-spacing 0.2))) (add-hook 'buffer-list-update-hook #'my:linespacing) my:linespacing はシンプルに、 global ではなく local 変数の line-spacing を書き換えます。 (minibufferp) で括っているのは、ミニバッファの行間を my:linespacing に左右されずに制御するためです。\ndarkroom-mode では、\n(setq-local line-spacing 0.4) と行間を大きくするように設定していますが、dark-room からでるときに my:linespacing に戻しています。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/web-mode/",
	"title": "7.3. web-mode",
	"tags": [],
	"description": "",
	"content": "[web-mode] HTML編集をサポート HTML編集をするならweb-mode がお勧めなのですが、私の場合あまり使っていません。\n出来上がったHTMLの内容を確認したり部分的に変更したり\u0026hellip;という程度の使い方です。\n(leaf web-mode :ensure t :mode (\u0026#34;\\\\.js?\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.html?\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.php?\\\\\u0026#39;\u0026#34;) :custom `((web-mode-markup-indent-offset . 2) (web-mode-css-indent-offset . 2) (web-mode-code-indent-offset . 2))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/auto-delete/",
	"title": "9.3. auto-delete",
	"tags": [],
	"description": "",
	"content": "8.2. 空になったファイルを自動的に削除 howm や org でメモをとるときに、ゴミファイルが残らないように時々メンテしています。ファイルを開いて中味を確認してから、一度閉じて dited で削除するというプロセスは手間がかかりすぎます。\n下記の設定をしておくと、C-x h で全選択して delete したあと kill-buffer することで自動的にファイルが削除されるので便利です。\n(defun my:delete-file-if-no-contents () \u0026#34;Automatic deletion for empty files (Valid in all modes).\u0026#34; (when (and (buffer-file-name (current-buffer)) (= (point-min) (point-max))) (delete-file (buffer-file-name (current-buffer))))) (if (not (memq \u0026#39;my:delete-file-if-no-contents after-save-hook)) (setq after-save-hook (cons \u0026#39;my:delete-file-if-no-contents after-save-hook))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/",
	"title": "カーソル移動",
	"tags": [],
	"description": "",
	"content": " カーソル移動に関する設定です。 ブラインドタッチは出来ない体質なので、文字移動、行移動、スクロールは、素直に上下左右の矢印キーとPgUp PgDn を使っています。   sequential-command 標準の C-a C-e を拡張します。 other-window-or-sptit 画面分割コマンド C-x 3 を拡張します。 jump-brace 括弧の先頭と最後へ交互にポイント移動します。 my:exchange-point-and-mark 直前の編集ポイントと現在のポイントとを行き来できる設定です。 expand-region カーソル位置を起点に選択範囲を賢く広げてくれるパッケージ。  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/sprit-window/",
	"title": "5.4. sprit-window-functions",
	"tags": [],
	"description": "",
	"content": "dimmer-mode との連携をさせるために、デフォルトのキーバインドをカスタマイズします。\n 同じバッファーを分割したときは、follow-mode にする。 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *cus-sprit-window :bind ((\u0026#34;C-q\u0026#34; . other-window-or-split) (\u0026#34;C-x 2\u0026#34; . my:split-window-below) (\u0026#34;C-x 1\u0026#34; . my:delete-other-windows) (\u0026#34;C-x 0\u0026#34; . my:delete-window) (\u0026#34;\u0026lt;C-return\u0026gt;\u0026#34; . window-swap-states)) :init (defun other-window-or-split () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (defun my:split-window-below () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (split-window-below) (follow-mode 1) (dimmer-mode 1)) (defun my:delete-window () \u0026#34;With turn off dimmer.\u0026#34; (interactive) (delete-window) (follow-mode -1) (dimmer-mode -1)) (defun my:delete-other-windows () \u0026#34;With turn off dimmer.\u0026#34; (interactive) (delete-other-windows) (follow-mode -1) (dimmer-mode -1)) (defun kill-other-buffers () \u0026#34;Kill all other buffers.\u0026#34; (interactive) (mapc \u0026#39;kill-buffer (delq (current-buffer) (buffer-list))) (message \u0026#34;killl-other-buffers!\u0026#34;)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/display-number/",
	"title": "7.4. display-number-mode",
	"tags": [],
	"description": "",
	"content": "(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) ((lisp-interaction-mode-hook dired-mode-hook). my:disable-modes)) :bind (\u0026#34;\u0026lt;f9\u0026gt;\u0026#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () \u0026#34;Disable modes in scrtch buffer.\u0026#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0) (nyan-mode 0))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/yatex/",
	"title": "7.4. yatex",
	"tags": [],
	"description": "",
	"content": "5.6. [yatex] YaTexで LaTex編集 yatex.el は、Emacsの上で動作する LaTeX の入力支援環境です。\nごく一般的な設定例ですが、参考になるとしたら dviprint-command-format に dvpd.sh というスクリプトを設定して、YateX.lpr コマンドでPDF作成 → プレビューまでの手順を一気に出来るように自動化している点でしょうか。\n(leaf yatex :ensure t :mode (\u0026#34;\\\\.tex\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.sty\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.cls\\\\\u0026#39;\u0026#34;) :custom `((tex-command . \u0026#34;platex\u0026#34;) (dviprint-command-format . \u0026#34;dvpd.sh %s\u0026#34;) (YaTeX-kanji-code . nil) (YaTeX-latex-message-code . \u0026#39;utf-8) (YaTeX-default-pop-window-height . 15)) :config (leaf yatexprc :bind ((\u0026#34;M-c\u0026#34; . YaTeX-typeset-buffer) (\u0026#34;M-v\u0026#34; . YaTeX-lpr)))) YaTeX-lpr は、dviprint-command-format を呼び出すコマンドです。\ndviファイルから dvipdfmx で PDF作成したあと、ビューアーを起動させて表示させるところまでをバッチファイルに書き、chmod +x dvpd.sh  として実行権限を付与してからPATHの通ったところに置きます。私は、/usr/loca/bin に置きました。\n[dvpd.sh]\n#!/bin/sh name=$1 dvipdfmx $1 \u0026amp;\u0026amp; evince ${name%.*}.pdf # Delete unnecessary files rm *.au* *.dv* *.lo* 上記の例では、ビューアーに Linux の evince を設定していますが、Mac の場合は、下記のようになるかと思います。\ndvipdfmx $1 \u0026amp;\u0026amp; open -a Preview.app ${name%.*}.pdf "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/recentf/",
	"title": "9.4. recentf",
	"tags": [],
	"description": "",
	"content": ";; recentf (leaf recentf :custom `((recentf-auto-cleanup . \u0026#39;never) (recentf-exclude . \u0026#39;(\u0026#34;\\\\.howm-keys\u0026#34; \u0026#34;Dropbox/backup\u0026#34; \u0026#34;.emacs.d/tmp/\u0026#34; \u0026#34;.emacs.d/elpa/\u0026#34; \u0026#34;/scp:\u0026#34;)))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/",
	"title": "フォント / 配色関連",
	"tags": [],
	"description": "",
	"content": "ここでは設定ファイルを見やすくするための配色関連の設定を記載している。\n font フォントの設定とインストール hl-line カーソル行に色をつける blink-cursor カーソルの点滅を制御する my:ivy-format ivyの選択行をアイコンで強調する volatile-highlights コピペした領域を強調する rainbow-mode カラーコードを実際の色に表示する rainbow-delimiters カラーコードを実際の色に表示する paren カラーコードを実際の色に表示する whitespace カラーコードを実際の色に表示する  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/tempbuf/",
	"title": "5.5. tempbuf",
	"tags": [],
	"description": "",
	"content": " tempbuf.el は不要になったと思われるバッファを自動的に kill してくれるパッケージ。 emacswiki.org/emacs/tempbuf.el: Automatically deleted in the background  使っていた時間が長い程、裏に回った時には長い時間保持してくれる。 つまり、一瞬開いただけのファイルは明示的に kill しなくても勝手にやってくれるのでファイルを開いてそのまま放置みたいなことをしがちなズボラな人間には便利なやつ。\n my:tembuf-ignore-files: 勝手に kill させないファイルの指定 find-file-hook: find-file や dired で開いたファイルが対象 dired buffer /magit-buffer: 強制的に削除  (leaf tempbuf :el-get minorugh/tempbuf :hook ((find-file-hook . my:find-file-tempbuf-hook) (dired-mode-hook . turn-on-tempbuf-mode) (magit-mode-hook . turn-on-tempbuf-mode) ) :init (setq my:tempbuf-ignore-files \u0026#39;(\u0026#34;~/Dropbox/org/task.org\u0026#34; \u0026#34;~/Dropbox/org/capture.org\u0026#34;)) (defun my:find-file-tempbuf-hook () (let ((ignore-file-names (mapcar \u0026#39;expand-file-name my:tempbuf-ignore-files))) (unless (member (buffer-file-name) ignore-file-names) (turn-on-tempbuf-mode))))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/darkroom/",
	"title": "7.5. darkroom",
	"tags": [],
	"description": "",
	"content": "[darkroom-mode] 執筆モード darkroom.el は、画面の余計な項目を最小限にして、文章の執筆に集中できるようにするパッケージです。\nhttps://github.com/joaotavora/darkroom\n[F12] キーで IN/OUT をトグルしています。 darkroom-mode から抜けるときは、revert-buffer で再読込してもとに戻します。\nyes/no確認を聞かれるのが煩わしいので my:revery-buffer-no-confirm の関数を作りました。\n(leaf darkroom :ensure t :bind ((\u0026#34;\u0026lt;f12\u0026gt;\u0026#34; . my:darkroom-in) (:darkroom-mode-map (\u0026#34;\u0026lt;f12\u0026gt;\u0026#34; . my:darkroom-out))) :config (defun my:darkroom-in () \u0026#34;Enter to the `darkroom-mode\u0026#39;.\u0026#34; (interactive) (view-mode 0) (diff-hl-mode 0) (display-line-numbers-mode 0) (darkroom-tentative-mode 1) (setq-local line-spacing 0.4)) (defun my:darkroom-out () \u0026#34;Returns from `darkroom-mode\u0026#39;to the previous state.\u0026#34; (interactive) (my:linespacing) (darkroom-tentative-mode 0) (display-line-numbers-mode 1) (my:revert-buffer-no-confirm)) (defun my:revert-buffer-no-confirm () \u0026#34;Revert buffer without confirmation.\u0026#34; (interactive) (revert-buffer t t))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/savehist/",
	"title": "9.5. savehist",
	"tags": [],
	"description": "",
	"content": ";; Don\u0026#39;t clear kill-ring when restart emacs (savehist-additional-variables . \u0026#39;(kill-ring)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/",
	"title": "フレーム / ウインドウ制御",
	"tags": [],
	"description": "",
	"content": "ここではバッファ / ウインドウ管理関係の設定を記載している\n dimmer 現在のバッファ以外の輝度を落とす scrool-other-window deactive なwindowをスクロールさせます。 sprit-window-function dimmer-mode 画面分割コマンドのカスタマイズ設定。 tempbuf 不要になったと思われるバッファを自動的に kill してくれる。 winner-mode ウインドウ構成の履歴を辿る doom-themes テーマの設定 doom-modeline モードラインの設定  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/winner/",
	"title": "5.6. winner-mode",
	"tags": [],
	"description": "",
	"content": "11.3. [Winner.el] ウインドウ構成の履歴を辿る  ビルトインの winner.el を使います．  ウィンドウ分割状況と各ウィンドウで表示していたバッファの履歴を辿ることができます。 winner-undo で直前の状態に戻せます。例えば、誤って C-x 0 で分割ウィンドウを閉じた時でも即座に元の状態に戻すことが可能です。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/ivy/",
	"title": "7.6. ivy / counsel",
	"tags": [],
	"description": "",
	"content": "ivy は、helm と双璧を成す Emacsの補完システムです。\nリスト表示された多くの選択肢から、自分が使いたいものを高速に絞り込んで効率良く選び出す。 このシンプルかつ極めて重要なタスクを ivy が手助けしてくれます．\n(leaf counsel :ensure t :defer-config (ivy-mode) :bind ((\u0026#34;C-r\u0026#34; . swiper-thing-at-point) (\u0026#34;C-s\u0026#34; . swiper-region) (\u0026#34;C-:\u0026#34; . counsel-switch-buffer) (\u0026#34;s-a\u0026#34; . counsel-ag) (\u0026#34;s-r\u0026#34; . counsel-rg) (\u0026#34;s-f\u0026#34; . counsel-fontawesome) (\u0026#34;M-x\u0026#34; . counsel-M-x) (\u0026#34;M-y\u0026#34; . counsel-yank-pop) (\u0026#34;C-x m\u0026#34; . counsel-mark-ring) (\u0026#34;C-x C-b\u0026#34; . ibuffer) (\u0026#34;C-x C-f\u0026#34; . counsel-find-file) (\u0026#34;C-x C-r\u0026#34; . counsel-recentf)) :custom `((search-default-mode . nil) (ivy-use-virtual-buffers . t) (ivy-use-selectable-prompt . t) (enable-recursive-minibuffers . t) (counsel-find-file-ignore-regexp . (regexp-opt completion-ignored-extensions)) (ivy-format-functions-alist . \u0026#39;((t . my:ivy-format-function-arrow))))) 現在の選択候補をわかりやすくする ivy-format-functions-alist にカスタマイズした関数を追加すれば、プロンプトの下部に位置するカーソル行の表示を変更できます。 all-the-icons を導入して好みのアイコンでカーソル行のある選択候補を目立たせましょう。\n(defun my:ivy-format-function-arrow (cands) \u0026#34;Transform into a string for minibuffer with CANDS.\u0026#34; (ivy--format-function-generic (lambda (str) (concat (if (display-graphic-p) (all-the-icons-octicon \u0026#34;chevron-right\u0026#34; :height 0.8 :v-adjust -0.05) \u0026#34;\u0026gt;\u0026#34;) (propertize \u0026#34; \u0026#34; \u0026#39;display `(space :align-to 2)) (ivy--add-face str \u0026#39;ivy-current-match))) (lambda (str) (concat (propertize \u0026#34; \u0026#34; \u0026#39;display `(space :align-to 2)) str)) cands \u0026#34;\\n\u0026#34;)) ivy-rich ivy-rich を導入するとアイコンが追加され、さらに追加の情報が空きスペースに記述されるようになります。\n(leaf ivy-rich :ensure t :hook (after-init-hook . ivy-rich-mode)) amx amx は、Emacsコマンド M-x の代替インターフェイスですが、コマンドの使用履歴を保存・利用してくれる優れものです。 導入することでcounsel-M-x とも自動的に連携して効率の良い補完システムを提供します。\n(leaf amx :ensure t :custom `((amx-save-file . ,\u0026#34;~/.emacs.d/tmp/amx-items\u0026#34;) (amx-history-length . 20))) swiper-region swiper-thing-at-point は賢くて親切なのですが、key-wordを入力して検索したいときには使いづらいです。 自分の使い勝手に合わせてカスタマイズしました。\n(defun swiper-region () \u0026#34;If region is selected, `swiper-thing-at-point\u0026#39;. If the region isn\u0026#39;t selected, `swiper\u0026#39;.\u0026#34; (interactive) (if (not (use-region-p)) (swiper) (swiper-thing-at-point))) 高速全文検索 2文字でも検索が発動するようにカスタマイズしています。@takaxp さんのTipsからパクってきました。\n(with-no-warnings (defun ad:counsel-ag (f \u0026amp;optional initial-input initial-directory extra-ag-args ag-prompt caller) (apply f (or initial-input (and (not (thing-at-point-looking-at \u0026#34;^\\\\*+\u0026#34;)) (ivy-thing-at-point))) (unless current-prefix-arg (or initial-directory default-directory)) extra-ag-args ag-prompt caller))) (with-eval-after-load \u0026#34;counsel\u0026#34; (require \u0026#39;thingatpt nil t) (advice-add \u0026#39;counsel-ag :around #\u0026#39;ad:counsel-ag) ;; Make search trigger even with 2 characters (add-to-list \u0026#39;ivy-more-chars-alist \u0026#39;(counsel-ag . 2)) (ivy-add-actions \u0026#39;counsel-ag \u0026#39;((\u0026#34;r\u0026#34; my:counsel-ag-in-dir \u0026#34;search in directory\u0026#34;)))) (defun my:counsel-ag-in-dir (_arg) \u0026#34;Search again with new root directory.\u0026#34; (let ((current-prefix-arg \u0026#39;(4))) (counsel-ag ivy-text nil \u0026#34;\u0026#34;))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/hist-files/",
	"title": "9.6. hist-files",
	"tags": [],
	"description": "",
	"content": ";; change-default-file-location (leaf change-default-file-location :custom `((recentf-save-file . \u0026#34;~/.emacs.d/tmp/recentf\u0026#34;) (save-place-file . \u0026#34;~/.emacs.d/tmp/places\u0026#34;) (savehist-file . \u0026#34;~/.emacs.d/tmp/history\u0026#34;) (url-configuration-directory . \u0026#34;~/.emacs.d/tmp/url\u0026#34;) (bookmark-file . \u0026#34;~/.emacs.d/tmp/bookmarks\u0026#34;))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/",
	"title": "編集サポート / 入力補助",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集や入力補助の設定をまとめている\n markdown-mode markdown記法での編集をサポートしてくれるマイナーモード。 view-mode ファイルの閲覧に特化した便利機能を提供してくれる。 web-mode HTML編集をするためのマイナーモードを提供してくれる。 yatex Emacsの上で動作する LaTeX の入力支援環境を提供する。 darkroom 書くことに集中できるようにバッファを調整してくれる。 ivy / counsel 多くの選択肢から、使いたいものを高速に絞り込んでくれる補完ツール。 yasunippets/ cpmpany キーをタイプした時点で自動的に補完候補が出てきてくれる。 key-chord 同時押しというキーバインドを提供してくれる。 smartparens 括弧などのペアを自動的に挿入してくれる。 iedit 択領域を別の文字列に置き換える。 migemo ローマ字のまま日本語をインクリメンタル検索を可能にする。 selected リージョン選択時のアクションを制御してくれる。Like sendto of windows. pangu-spacing 全角と半角の間に自動でスペースを入れる。 counsel-fontawesome Font-Awesomeの入力を支援してくれる。  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/doom-themes/",
	"title": "5.7. doom-thmes",
	"tags": [],
	"description": "",
	"content": "(leaf doom-themes :ensure t :hook (after-init-hook . (lambda () (load-theme \u0026#39;doom-dracula t))) :custom (doom-themes-enable-italic . nil) (doom-themes-enable-bold . nil) :config (doom-themes-neotree-config) (doom-themes-org-config)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/company/",
	"title": "7.7. yasunippets / company",
	"tags": [],
	"description": "",
	"content": "(leaf yasnippet :ensure t :hook (after-init-hook . yas-global-mode) :config (leaf yasnippet-snippets :ensure t)) (leaf company :ensure t :hook (after-init-hook . global-company-mode) :bind ((\u0026#34;C-\u0026lt;return\u0026gt;\u0026#34; . company-complete) (\u0026#34;C-\u0026lt;tab\u0026gt;\u0026#34; . company-yasnippet) (:company-active-map (\u0026#34;\u0026lt;tab\u0026gt;\u0026#34; . company-complete-common-or-cycle) (\u0026#34;\u0026lt;backtab\u0026gt;\u0026#34; . company-select-previous) (\u0026#34;\u0026lt;muhenkan\u0026gt;\u0026#34; . company-abort))) :custom `((company-transformers . \u0026#39;(company-sort-by-backend-importance)) (company-idle-delay . 0) (company-require-match . \u0026#39;never) (company-minimum-prefix-length . 2) (company-selection-wrap-around . t) (completion-ignore-case . t) (company-dabbrev-downcase . nil)) :config (defvar company-mode/enable-yas t \u0026#34;Enable yasnippet for all backends.\u0026#34;) (defun company-mode/backend-with-yas (backend) (if (or (not company-mode/enable-yas) (and (listp backend) (member \u0026#39;company-yasnippet backend))) backend (append (if (consp backend) backend (list backend)) \u0026#39;(:with company-yasnippet)))) (setq company-backends (mapcar #\u0026#39;company-mode/backend-with-yas company-backends))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/dired/",
	"title": "9.7. dired",
	"tags": [],
	"description": "",
	"content": "(leaf dired :hook ((dired-mode-hook . dired-my-append-buffer-name-hint) (dired-mode-hook . (lambda () (load \u0026#34;dired-x\u0026#34;) (dired-omit-mode 1)))) :bind (:dired-mode-map (\u0026#34;\u0026lt;left\u0026gt;\u0026#34; . dired-up-alternate-directory) (\u0026#34;\u0026lt;right\u0026gt;\u0026#34; . dired-open-in-accordance-with-situation) (\u0026#34;RET\u0026#34; . dired-open-in-accordance-with-situation) (\u0026#34;\u0026lt;\u0026#34; . beginning-of-buffer) (\u0026#34;\u0026gt;\u0026#34; . end-of-buffer) (\u0026#34;SPC\u0026#34; . my:dired-toggle-mark) (\u0026#34;C-g\u0026#34; . my:dired-unmark-all) (\u0026#34;f\u0026#34; . counsel-find-file) (\u0026#34;r\u0026#34; . wdired-change-to-wdired-mode) (\u0026#34;o\u0026#34; . dired-open-file) (\u0026#34;[\u0026#34; . dired-hide-details-mode) (\u0026#34;a\u0026#34; . toggle-dired-listing-switches) (\u0026#34;q\u0026#34; . dired-dwim-quit-window) (\u0026#34;i\u0026#34; . call-sxiv) (\u0026#34;s\u0026#34; . sudo-edit) (\u0026#34;e\u0026#34; . gedit-open-dired) (\u0026#34;@\u0026#34; . dired-do-gist) (\u0026#34;.\u0026#34; . dired-omit-mode)) :custom `((dired-dwim-target . t) (delete-by-moving-to-trash . t) (dired-recursive-copies . \u0026#39;always) (dired-recursive-deletes . \u0026#39;always) (dired-listing-switches . \u0026#34;-lgGhF\u0026#34;) (dired-omit-files . \u0026#34;.elc\u0026#34;) (ls-lisp-use-insert-directory-program . nil) (ls-lisp-dirs-first . t))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; Dired custom configurations ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (with-eval-after-load \u0026#39;dired (defun toggle-dired-listing-switches () \u0026#34;Toggle `dired-mode\u0026#39;switch between with and without \u0026#39;A\u0026#39; option to show or hide dot files.\u0026#34; (interactive) (progn (if (string-match \u0026#34;[Aa]\u0026#34; dired-listing-switches) (setq dired-listing-switches \u0026#34;-lgGhF\u0026#34;) (setq dired-listing-switches \u0026#34;-lgGhFA\u0026#34;)) (reload-current-dired-buffer))) (defun reload-current-dired-buffer () \u0026#34;Reload current `dired-mode\u0026#39;buffer.\u0026#34; (let* ((dir (dired-current-directory))) (progn (kill-buffer (current-buffer)) (dired dir)))) (defun dired-my-append-buffer-name-hint () \u0026#34;Append a auxiliary string [Dir] to a name of dired buffer.\u0026#34; (when (eq major-mode \u0026#39;dired-mode) (let* ((dir (expand-file-name list-buffers-directory)) ;; Add a drive letter for Windows (drive (if (and (eq \u0026#39;system-type \u0026#39;windows-nt) (string-match \u0026#34;^\\\\([a-zA-Z]:\\\\)/\u0026#34; dir)) (match-string 1 dir) \u0026#34;\u0026#34;))) (rename-buffer (concat (buffer-name) \u0026#34; [\u0026#34; drive \u0026#34;dir]\u0026#34;) t)))) (defun dired-dwim-quit-window () \u0026#34;`quit-window \u0026#39;according to screen division.\u0026#34; (interactive) (quit-window (not (delq (selected-window) (get-buffer-window-list))))) (defun dired-open-in-accordance-with-situation () \u0026#34;Files are opened in separate buffers, directories are opened in the same buffer.\u0026#34; (interactive) (let ((file (dired-get-filename))) (if (file-directory-p file) (dired-find-alternate-file) (dired-find-file) ;; If in org-mode, open with view-mode (if (equal major-mode \u0026#39;org-mode) (view-mode 1))))) (defun dired-up-alternate-directory () \u0026#34;Move to higher directory without make new buffer.\u0026#34; (interactive) (let* ((dir (dired-current-directory)) (up (file-name-directory (directory-file-name dir)))) (or (dired-goto-file (directory-file-name dir)) ;; Only try dired-goto-subdir if buffer has more than one dir. (and (cdr dired-subdir-alist) (dired-goto-subdir up)) (progn (find-alternate-file up) (dired-goto-file dir))))) (defun dired-open-file () \u0026#34;In dired, open the file in associated application.\u0026#34; (interactive) (let* ((file (dired-get-filename nil t))) (call-process \u0026#34;xdg-open\u0026#34; nil 0 nil file))) (defun my:dired-toggle-mark (arg) \u0026#34;ARG toggle the current next files.\u0026#34; (interactive \u0026#34;p\u0026#34;) (let ((dired-marker-char (if (save-excursion (beginning-of-line) (looking-at \u0026#34; \u0026#34;)) dired-marker-char ?\\040))) (dired-mark arg))) (defun my:dired-unmark-all () \u0026#34;Dired unmark all.\u0026#34; (interactive) (call-interactively \u0026#39;dired-unmark-all-marks) (call-interactively \u0026#39;revert-buffer)) ;; Show all images in the directory ;; https://gist.github.com/kobapan/28908b564b610bd3e6f3fae78637ac8b (defun call-sxiv () \u0026#34;Image viewer.\u0026#34; (interactive) (let ((image-files (delq nil (mapcar (lambda (f) (when (string-match \u0026#34;\\.\\\\(jpe?g\\\\|png\\\\|gif\\\\|bmp\\\\)$\u0026#34; f) f)) (directory-files default-directory))))) ;; File list in the current directory in alphabetical order (start-process-shell-command \u0026#34;sxiv\u0026#34; nil (format \u0026#34;sxiv -f -t -n %s %s\u0026#34; (length image-files) (mapconcat \u0026#39;identity image-files \u0026#34; \u0026#34;)))))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/",
	"title": "表示サポート",
	"tags": [],
	"description": "",
	"content": "ここにはファイル編集や入力補助の設定をまとめている\n display 認証情報の取り扱いファイルの設定 all-the-icons 認証情報の取り扱いファイルの設定 display-number 認証情報の取り扱いファイルの設定 linespacing 認証情報の取り扱いファイルの設定 imenu-list 認証情報の取り扱いファイルの設定 diff-hl 認証情報の取り扱いファイルの設定 which-key 認証情報の取り扱いファイルの設定 prescient 認証情報の取り扱いファイルの設定 calendar 認証情報の取り扱いファイルの設定 toggle-fullscreen 認証情報の取り扱いファイルの設定  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/frame/doom-modeline/",
	"title": "5.8. doom-modeline",
	"tags": [],
	"description": "",
	"content": "(leaf doom-modeline :ensure t :hook (after-init-hook . doom-modeline-mode) :custom (doom-modeline-icon . t) (doom-modeline-major-mode-icon . nil) (doom-modeline-minor-modes . nil) :config (line-number-mode 0) (column-number-mode 0) (doom-modeline-def-modeline \u0026#39;main \u0026#39;(bar window-number matches buffer-info remote-host buffer-position parrot selection-info) \u0026#39;(misc-info persp-name lsp github debug minor-modes input-method major-mode process vcs checker)) :init (leaf nyan-mode :ensure t :config (nyan-mode 1) (nyan-start-animation))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/key-chord/",
	"title": "7.8. key-chord",
	"tags": [],
	"description": "",
	"content": "[key-chord.el] 同時押しでキーバインド  同時押しというキーバインドを提供してくれるやつ 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。  (leaf key-chord :ensure t :hook (after-init-hook . key-chord-mode) :chord ((\u0026#34;df\u0026#34; . counsel-descbinds) (\u0026#34;l;\u0026#34; . init-loader-show-log) (\u0026#34;@@\u0026#34; . howm-list-all) (\u0026#34;jk\u0026#34; . open-junk-file)) :custom `((key-chord-two-keys-delay . 0.25) (key-chord-safety-interval-backward . 0.1) (key-chord-safety-interval-forward . 0.15))) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。\n改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動にも使っている上に、よく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/neotree/",
	"title": "9.8. neotree",
	"tags": [],
	"description": "",
	"content": "(leaf neotree :ensure t :bind ((\u0026#34;\u0026lt;f10\u0026gt;\u0026#34; . neotree-find) (:neotree-mode-map (\u0026#34;RET\u0026#34; . neotree-enter-hide) (\u0026#34;a\u0026#34; . neotree-hidden-file-toggle) (\u0026#34;\u0026lt;left\u0026gt;\u0026#34; . neotree-select-up-node) (\u0026#34;\u0026lt;right\u0026gt;\u0026#34; . neotree-change-root) (\u0026#34;\u0026lt;f10\u0026gt;\u0026#34; . neotree-toggle))) :custom `((neo-keymap-style . \u0026#39;concise) (neo-create-file-auto-open . t))) (with-eval-after-load neotree ;; Change neotree\u0026#39;s font size ;; Tips from https://github.com/jaypei/emacs-neotree/issues/218 (defun neotree-text-scale () \u0026#34;Neotree text scale.\u0026#34; (interactive) (text-scale-adjust 0) (text-scale-decrease 0.8) (message nil)) (add-hook \u0026#39;neo-after-create-hook (lambda (_) (call-interactively \u0026#39;neotree-text-scale))) ;; neotree enter hide ;; Tips from https://github.com/jaypei/emacs-neotree/issues/77 (defun neo-open-file-hide (full-path \u0026amp;optional arg) \u0026#34;Neotree enter hide with FULL-PATH ARG.\u0026#34; (neo-global--select-mru-window arg) (find-file full-path) (neotree-hide)) (defun neotree-enter-hide (\u0026amp;optional arg) \u0026#34;Neotree enter hide with ARG.\u0026#34; (interactive \u0026#34;P\u0026#34;) (neo-buffer--execute arg \u0026#39;neo-open-file-hide \u0026#39;neo-open-dir))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/hydra/",
	"title": "Hydra / コマンドディスパッチャ",
	"tags": [],
	"description": "",
	"content": "hydra.el を使うとよく使う機能をまとめてシンプルなキーバインドを割り当てることができます。\n日本では、smartrep.el が有名だったようですが、hydra.elも同様の機能を提供します。\nQitta に詳しい記事を書いています。  Hydraで Emacsのキーバインド問題を解消  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/smartparens/",
	"title": "7.9. smartparens",
	"tags": [],
	"description": "",
	"content": "対応する括弧の挿入をアシスト smartparens.el の設定がいまいちよくわからず、とりあえず次のように設定して今のところ機嫌よく働いている。\n(leaf smartparens :ensure t :require smartparens-config :hook (prog-mode-hook . turn-on-smartparens-mode) :config (smartparens-global-mode t)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/history/",
	"title": "履歴 / ファイル管理",
	"tags": [],
	"description": "",
	"content": "ここでは Emacs ファイル管理関係の設定を載せている\n auto-seve-buffer ファイルの自動保存機能を提供します。 undo-fu ファイルの自動保存機能を提供します。 auto-deleter ファイルの自動保存機能を提供します。 recentf ファイルの自動保存機能を提供します。 savehist ファイルの自動保存機能を提供します。 hist-files ファイルの自動保存機能を提供します。 dired ファイルの自動保存機能を提供します。 neotree ファイルの自動保存機能を提供します。  "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/iedit/",
	"title": "7.10. iedit",
	"tags": [],
	"description": "",
	"content": "[iedit] 選択領域を別の文字列に置き換える  idet.el は、バッファー内の複数箇所を同時に編集するツールです。  同じような機能のものは、複数あるようですが、わたしはこれを愛用しています。\n multi-cursors.el replace-from-region.el anzu.el  MELPAからpackage-installするだけで使えます。\n対象範囲を選択して C-; を押すとiedit-modeとなり、選択したキーワードが全てハイライト表示され、モードラインに押すとIedit:とキーワードの出現した回数が表示され、ミニバッファにもメッセージが表示されます。\nここで、ハイライトされた部分を編集すると、他のハイライトも同時に編集されるようになります。編集後、もう一度 C-; を押すと確定されiedet-modeを抜けます。\nかなりの頻度で使うので、Emacsでは使うことのない \u0026lt;insert\u0026gt; にキーバインドしています。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/programming/",
	"title": "開発サポート",
	"tags": [],
	"description": "",
	"content": "ここでは各言語やフレームワーク毎の設定をまとめている。 markdown-mode とか yaml-mode なんかはプログラム言語ではないけど面倒なので一旦ここにまとめている。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/migemo/",
	"title": "7.11. migemo",
	"tags": [],
	"description": "",
	"content": "[migemo] ローマ字のまま日本語をインクリメンタル検索可能にする。 migemo は元々 Ruby で書かれていたようですが，最近の Ruby では動かないので C 言語で再実装された cmigemo を使うのが一般的のよう。 aptでインストール。\n$ sudo apt install cmigemo インストール完了したら、下記コマンドで実行できる事を確認しておきます。\n$ cmigemo --help Emacsの設定は下記のとおりです。\n(leaf migemo :ensure t :hook (after-init-hook . migemo-init) :when (executable-find \u0026#34;cmigemo\u0026#34;) :custom `((migemo-command . \u0026#34;cmigemo\u0026#34;) (migemo-dictionary . \u0026#34;/usr/share/cmigemo/utf-8/migemo-dict\u0026#34;))) [swiper-migemo] swiperでもmigemoを使う avy-migemo-e.g.swiper.el を使って出来ていたのですが、２年ほど前から更新が止まってしまっていて動きません。\nつい最近、avy-migemo を使わない swiper-migemoを GitHubで見つけたので試した処、機嫌よく動いてくれています。 MELPAにはアップされていないみたいなので el-get で取得しています。\n(leaf swiper-migemo :doc \u0026#34;https://github.com/tam17aki/swiper-migemo\u0026#34; :el-get tam17aki/swiper-migemo :config (global-swiper-migemo-mode +1)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/external-tool/",
	"title": "外部連携ツール設定",
	"tags": [],
	"description": "",
	"content": "ここでは外部のサービスと連携するようなやつをまとめています\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/selected/",
	"title": "7.12. selected",
	"tags": [],
	"description": "",
	"content": "[selected] リージョン選択時のアクションを制御 selected.el は、選択領域に対するスピードコマンドです。\nEmacsバッファーで領域を選択した後、バインドしたワンキーを入力するとコマンドが実行されます。 コマンドの数が増えてきたら、ヘルプ代わりに使える counsel-selected も便利そうです。\n(leaf selected :ensure t :hook (after-init-hook . selected-global-mode) :bind (:selected-keymap (\u0026#34;;\u0026#34; . comment-dwim) (\u0026#34;c\u0026#34; . clipboard-kill-ring-save) (\u0026#34;s\u0026#34; . swiper-thing-at-point) (\u0026#34;t\u0026#34; . google-translate-auto) (\u0026#34;T\u0026#34; . chromium-translate) (\u0026#34;W\u0026#34; . my:weblio) (\u0026#34;k\u0026#34; . my:koujien) (\u0026#34;e\u0026#34; . my:eijiro) (\u0026#34;g\u0026#34; . my:google))) browse-urlで検索サイトで開く 検索結果を browse-url で表示させるユーザーコマンドは、検索 urlのフォーマットとさえわかれば、パッケージツールに頼らずともお好みのマイコマンドを作成できます。\n(defun my:koujien (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://sakura-paris.org/dict/広辞苑/prefix/%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:weblio (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://www.weblio.jp/content/%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:eijiro (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://eow.alc.co.jp/%s/UTF-8/\u0026#34; (upcase (url-hexify-string str))))) (defun my:google (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://www.google.com/search?hl=ja\u0026amp;q=%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:get-region (r) \u0026#34;Get search word from region.\u0026#34; (buffer-substring-no-properties (region-beginning) (region-end))) IME のオン・オフを自動制御する selectedコマンドを選択するときは、IMEをOffにしないといけないのですがこれを自動でさせます。\n領域を選択し始める時に IMEをオフにして、コマンド発行後に IMEを元に戻すという例が、 @takaxp さんの Qiitaの記事 にあったので、私の環境（emacs-mozc ）にあうように設定したら、すんなり動いてくれました。感謝！\n(leaf *cus-selected :hook ((activate-mark-hook . my:activate-selected) (activate-mark-hook . (lambda () (setq my:ime-flag current-input-method) (my:ime-off))) (deactivate-mark-hook . (lambda () (unless (null my:ime-flag) (my:ime-on))))) :init ;; Control mozc when seleceted (defun my:activate-selected () (selected-global-mode 1) (selected--on) (remove-hook \u0026#39;activate-mark-hook #\u0026#39;my:activate-selected)) (add-hook \u0026#39;activate-mark-hook #\u0026#39;my:activate-selected) (defun my:ime-on () (interactive) (when (null current-input-method) (toggle-input-method))) (defun my:ime-off () (interactive) (inactivate-input-method)) (defvar my:ime-flag nil) (add-hook \u0026#39;activate-mark-hook #\u0026#39;(lambda () (setq my:ime-flag current-input-method) (my:ime-off))) (add-hook \u0026#39;deactivate-mark-hook #\u0026#39;(lambda () (unless (null my:ime-flag) (my:ime-on))))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/memo-tool/",
	"title": "メモ環境",
	"tags": [],
	"description": "",
	"content": "ここでは org-mode 周りの設定をまとめている。 org-mode だけでも書くことが多いからね……。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/pangu/",
	"title": "7.13. pangu-spacing",
	"tags": [],
	"description": "",
	"content": ";; Add space between full-width and half-width (leaf pangu-spacing :ensure t :after mozc :hook ((markdown-mode-hook text-mode-hook) . pangu-spacing-mode) :config (setq pangu-spacing-include-regexp (rx (or (and (or (group-n 3 (any \u0026#34;。，！？；：「」（）、\u0026#34;)) (group-n 1 (or (category japanese)))))) (group-n 2 (in \u0026#34;a-zA-Z\u0026#34;))))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/utility-tool/",
	"title": "ユーティリティー関数",
	"tags": [],
	"description": "",
	"content": "自動テストを実行するにあたり、追加インストールしているパッケージをここに載せている\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/editing/fontawesome/",
	"title": "7.14. fontawesome",
	"tags": [],
	"description": "",
	"content": "Font-awesome の入力をcounsel で支援してくれる。\n(leaf fontawesome :ensure t :bind (\u0026#34;s-f\u0026#34; . counsel-fontwesame)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/hydra/hydra-make/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://minorugh.github.io/.emacs.d/hydra/hydra-markdown/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://minorugh.github.io/.emacs.d/hydra/hydra-quick/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "7.1. [hydra-menu] 作業選択メニュー hydra-work-menu には、 ブログ記事のほかWEB日記や俳句関係のシリーズ記事の追加、編集など、毎日頻繁に開くワークスペースへのショートカットを設定しています。\nhydra-quick-menu の方には、 編集作業で頻繁に使うツール群のほか、my:dired でプロジェクトのディレクトリを一発で開くためのショートカットなどを設定しています。\nこの２つの hydra は、いわば私の秘書のような役割で、どちらからでも相互にトグルで呼び出せるようにしています。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/hydra/hydra-work/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/eary-init/",
	"title": "1.1. eary-init.el",
	"tags": [],
	"description": "",
	"content": " early-init.el は、Emacs27から導入されました。 minorugh/.emacs.d/early-init.el  init.el でパッケージシステムやGUIの初期化が実行される前にロードされるので、UI関係や package-enable-at-startup のようなパッケージ初期化プロセスに影響を与える変数をカスタマイズできます。\nGCを減らす GC の閾値を最大にしておくことで GC を実質止めることができます。とりあえず書いておけば速くなる系なのでおすすめです。\n;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) eary-init.el の先頭に書くことが重要です。\nPackage の初期化を抑制する Emacs27では、(package-initialize) が 2回実行されます。 (1回は init ファイルの評価中に、もう 1回は Emacs が initファイルの読み取りを終了した後に)。\n1回目を抑制するために以下を eary-init.el に記述することで初期化が少し早くなります。\n;; For slightly faster startup (setq package-enable-at-startup nil) 常に最新のバイトコードをロードする ;; Always load newest byte code (setq load-prefer-newer t) フレームのサイズ変更を禁止する ;; Inhibit resizing frame (setq frame-inhibit-implied-resize t) これらを無効にする方が速い (初期化される前) ;; Faster to disable these here (before they\u0026#39;ve been initialized) (push \u0026#39;(fullscreen . maximized) default-frame-alist) (push \u0026#39;(menu-bar-lines . 0) default-frame-alist) (push \u0026#39;(tool-bar-lines . 0) default-frame-alist) (push \u0026#39;(vertical-scroll-bars) default-frame-alist) 起動時の点滅を抑える Emacsが設定ファイルを読み込むプロセスで画面がちらつくのを抑制します。\n;; Suppress flashing at startup (setq inhibit-redisplay t) (setq inhibit-message t) (add-hook \u0026#39;window-setup-hook (lambda () (setq inhibit-redisplay nil) (setq inhibit-message nil) (toggle-fullscreen) (redisplay))) 起動時の背景色を指定する Emacsが設定を読み込む色段階の背景色は白です。 自分は、タークテーマを使っているので、起動時から即黒背景になるようにここで設定しています。\n;; Startup setting (setq inhibit-splash-screen t) (setq inhibit-startup-message t) (setq byte-compile-warnings \u0026#39;(cl-functions)) (custom-set-faces \u0026#39;(default ((t (:background \u0026#34;#282a36\u0026#34;))))) Emacsのを常駐環境を考えてみた GUIのEmacsをシステム的に常駐化させるのは、自分にはハードルが高いので疑似環境ということでご紹介します。\n Linux起動時に最小化で自動起動させる C-x C-c で閉じれないようにする（restert-emacsに割り当てています） 誤ってフレームの閉じるボタンを押せないようにする（常にフルスクリーンで使う） 画面を閉じるときは、最小化（C-z: suspend-frame）させる  Emacsは、起動オプションに --iconic を付すことで最小化起動します。\nLinuxの場合、「セッションと起動」を立ち上げて「自動開始アプリケーション」に下記の設定を追加するといいです。\n$ emacs --iconic "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/speed-up/",
	"title": "1.2. speed up startup",
	"tags": [],
	"description": "",
	"content": " Magic File Name を一時的に無効にすることで、起動時間を短縮できます。 GC設定とともに設定ファイル読み込み後に正常値に戻します。  ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook \u0026#39;emacs-startup-hook (lambda () \u0026#34;Recover file name handlers.\u0026#34; (setq file-name-handler-alist (delete-dups (append file-name-handler-alist old-file-name-handler-alist))))))) ;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) (add-hook \u0026#39;emacs-startup-hook (lambda () \u0026#34;Recover GC values after startup.\u0026#34; (setq gc-cons-threshold 800000))) ※ init.el の先頭に書きます。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/leaf/",
	"title": "1.3. leaf.el",
	"tags": [],
	"description": "",
	"content": "Emacsの設定管理は、これまで use-pacage.el を使っていましたが、 @conao3 さんの開発された leaf.el に触発されて全面的に書き直しました。\n Emacs入門から始めるleaf.el入門  leaf.el に対応したinit.el Packageは、基本MELPAからインストールしていますが、el-getも使えるようにしています。 自作パッケージもGitHubリポジトリで管理してel-getでインストールすることでシンプルなパッケージ管理が出来ます。\n;;; init.el --- Emacs first Configuration. -*- lexical-binding: t -*- ;;; Commentary: ;; ;; Compatible with Emacs 27 and later ;; Aiming for a fancy and fast Emacs configuration ;; ;;; Code: ;; (setq debug-on-error t) ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook \u0026#39;emacs-startup-hook (lambda () \u0026#34;Recover file name handlers.\u0026#34; (setq file-name-handler-alist (delete-dups (append file-name-handler-alist old-file-name-handler-alist))))))) ;; Defer garbage collection further back in the startup process (add-hook \u0026#39;emacs-startup-hook (lambda () \u0026#34;Recover GC values after startup.\u0026#34; (setq gc-cons-threshold 800000))) ;; Package (eval-and-compile (customize-set-variable \u0026#39;package-archives \u0026#39;((\u0026#34;org\u0026#34; . \u0026#34;https://orgmode.org/elpa/\u0026#34;) (\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) (\u0026#34;gnu\u0026#34; . \u0026#34;https://elpa.gnu.org/packages/\u0026#34;))) (package-initialize) (unless (package-installed-p \u0026#39;leaf) (package-refresh-contents) (package-install \u0026#39;leaf)) (leaf leaf-keywords :ensure t :init (leaf hydra :ensure t) (leaf el-get :ensure t) :config (leaf-keywords-init) (setq custom-file (locate-user-emacs-file \u0026#34;~/.emacs.d/tmp/custom.el\u0026#34;)))) ;; Load init files (leaf init-loader :ensure t :config (custom-set-variables \u0026#39;(init-loader-show-log-after-init \u0026#39;error-only)) (init-loader-load)) (provide \u0026#39;init) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;; init.el ends here "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/init-loader/",
	"title": "1.4. init-loader.el",
	"tags": [],
	"description": "",
	"content": "[init-loader.el] 設定ファイル群のローダー  emacs-jp/init-loader:Loader of configuration files.  指定されたディレクトリから構成ファイルをロードします。これにより、構成を分類して複数のファイルに分けることができます。\ninit-loader には、エラーが出た設定ファイルは読み込まれない\u0026hellip;という特徴があり原因究明がしやすくなるというメリットがある。またログの出力機能を備えていることもメリットとして挙げられる。\n起動時間が犠牲になるということで敬遠される向きもあるが微々たるもので、恩恵のほうが遥かに大きい。\n(leaf init-loader :ensure t :config (custom-set-variables \u0026#39;(init-loader-show-log-after-init \u0026#39;error-only)) (init-loader-load)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/test/",
	"title": "1.5. test.el",
	"tags": [],
	"description": "",
	"content": "[test.el] 最小限の emacs を起動させるための設定 test.el は、 新しいパッケージを試したり設定をテストしたり、エラー等で Emacsが起動しない場合などに使用します。\n以下を .zshrc または .coderc に記述し反映させたのち、シェルから eq と入力することで起動することがでます。\nalias eq = \u0026#39;emacs -q -l ~/.emacs.d/test.el\u0026#39; ファイルの PATH は、ご自分の環境に応じて修正が必要です。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/startup/dashboard/",
	"title": "1.6. dashboard",
	"tags": [],
	"description": "",
	"content": "[dashboard.el]起動初期画面をイケメンにする 100分の1秒でもemacsの起動を早くしようと試行錯誤している一方、せめて初期画面くらいは、ホットするようなものにしたい…ということで、dashbord.el を導入してみた。\nemacs-dashboard: An extensible emacs startup screen\n どのような状況からでも dashboard画面に戻れるように設定しています。 \u0026lt;home\u0026gt; キーのトグル操作で編集中のバッファーとdashboard画面とを行き来します。  (leaf dashboard :ensure t :hook ((after-init-hook . dashboard-setup-startup-hook) (dashboard-mode-hook . page-break-lines-mode)) :defun (dashboard-setup-startup-hook) :bind ((\u0026#34;\u0026lt;home\u0026gt;\u0026#34; . open-dashboard) (:dashboard-mode-map (\u0026#34;c\u0026#34; . chromium-calendar) (\u0026#34;y\u0026#34; . chromium-yahoo-japan) (\u0026#34;n\u0026#34; . chromium-nhk-news) (\u0026#34;w\u0026#34; . chromium-weather) (\u0026#34;t\u0026#34; . chromium-tweetdeck) (\u0026#34;h\u0026#34; . chromium-homepage) (\u0026#34;m\u0026#34; . sylpheed) (\u0026#34;s\u0026#34; . slack) (\u0026#34;.\u0026#34; . hydra-browse/body) (\u0026#34;\u0026lt;home\u0026gt;\u0026#34; . quit-dashboard))) :advice (:override emacs-init-time ad:emacs-init-time) :init (leaf page-break-lines :ensure t) :config ;; Set the title (setq dashboard-banner-logo-title (concat \u0026#34;GNU Emacs \u0026#34; emacs-version \u0026#34; kernel \u0026#34; (car (split-string (shell-command-to-string \u0026#34;uname -r\u0026#34;))) \u0026#34; Debian \u0026#34; (car (split-string (shell-command-to-string \u0026#34;cat /etc/debian_version\u0026#34;))) \u0026#34; 86_64 GNU/Linux\u0026#34;)) ;; Set the banner (setq dashboard-startup-banner (expand-file-name \u0026#34;emacs.png\u0026#34; user-emacs-directory) dashboard-page-separator \u0026#34;\\n\\f\\f\\n\u0026#34; dashboard-set-heading-icons t dashboard-set-file-icons t show-week-agenda-p t dashboard-items \u0026#39;((recents . 5) (agenda . 5))) ;; Set the footer (setq dashboard-footer-messages \u0026#39;(\u0026#34;Always be joyful. Never stop praying. Be thankful in all circumstances.\u0026#34;)) (setq dashboard-footer-icon (all-the-icons-octicon \u0026#34;dashboard\u0026#34; :height 1.0 :v-adjust -0.05 :face \u0026#39;font-lock-keyword-face)) (defun dashboard-insert-custom (list-size) \u0026#34;Insert custom itemes LIST-SIZE.\u0026#34; (interactive) (insert \u0026#34; GH: (h)  calendar: (c)  News: (n.y.w)  Mail: (m)  Slack: (s)  Twitter: (t)  (.)\u0026#34;)) ;; Insert custom item (add-to-list \u0026#39;dashboard-item-generators \u0026#39;(custom . dashboard-insert-custom)) (add-to-list \u0026#39;dashboard-items \u0026#39;(custom) t)) カスタマイズ設定 dashbord画面を好みにカスタマイズするためのユーザー関数です。\n;; Custom configurations (defun dashboard-goto-recent-files () \u0026#34;Go to recent files.\u0026#34; (interactive) (let ((func (local-key-binding \u0026#34;r\u0026#34;))) (and func (funcall func)))) (defvar dashboard-recover-layout-p nil \u0026#34;Wether recovers the layout.\u0026#34;) (defun open-dashboard () \u0026#34;Open the *dashboard* buffer and jump to the first widget.\u0026#34; (interactive) (if (length\u0026gt; (window-list-1) (if (and (fboundp \u0026#39;treemacs-current-visibility) (eq (treemacs-current-visibility) \u0026#39;visible)) 2 1)) (setq dashboard-recover-layout-p t)) (delete-other-windows) (dashboard-refresh-buffer) (dashboard-goto-recent-files)) (defun quit-dashboard () \u0026#34;Quit dashboard window.\u0026#34; (interactive) (quit-window t) (when (and dashboard-recover-layout-p (bound-and-true-p winner-mode)) (winner-undo) (setq dashboard-recover-layout-p nil))) ;; Return a string giving the duration of the Emacs initialization (defun ad:emacs-init-time () \u0026#34;Advice `emacs-init-time\u0026#39;.\u0026#34; (interactive) (let ((str (format \u0026#34;%.3f seconds\u0026#34; (float-time (time-subtract after-init-time before-init-time))))) (if (called-interactively-p \u0026#39;interactive) (message \u0026#34;%s\u0026#34; str) str))) (defun sylpheed () \u0026#34;Open sylpheed.\u0026#34; (interactive) (compile \u0026#34;sylpheed\u0026#34;) (delete-other-windows)) (defun slack () \u0026#34;Open sylpheed.\u0026#34; (interactive) (compile \u0026#34;slack\u0026#34;) (delete-other-windows)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/encode/",
	"title": "2.1. language / coding",
	"tags": [],
	"description": "",
	"content": "シンプルにこれだけです。\n(set-language-environment \u0026#34;Japanese\u0026#34;) (prefer-coding-system \u0026#39;utf-8) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/mozc/",
	"title": "2.3. emacs-mozc",
	"tags": [],
	"description": "",
	"content": " Debian11 にインストールした Emacs上で emacs-mozc を使っています。 debian でのインストール手順は以下の通り。  $ sudo apt-get install fcitx-mozc emacs-mozc Emacsをソースからビルドするときに --without-xim しなかったので、インライン XIMでも日本語入力ができてしまいます。 特に使い分けする必要もなく紛らわしいので .Xresources で XIM無効化の設定をしました。\n! ~/.Xresources ! Emacs XIMを無効化 Emacs*useXIM: false 句読点などを入力したとき、わざわざ mozcに変換してもらう必要はないので以下を設定しておくことでワンアクションスピーディーになります。\n(leaf mozc :ensure t :bind ((\u0026#34;\u0026lt;hiragana-katakana\u0026gt;\u0026#34; . toggle-input-method) (:mozc-mode-map (\u0026#34;,\u0026#34; . (lambda () (interactive) (mozc-insert-str \u0026#34;、\u0026#34;))) (\u0026#34;.\u0026#34; . (lambda () (interactive) (mozc-insert-str \u0026#34;。\u0026#34;))) (\u0026#34;?\u0026#34; . (lambda () (interactive) (mozc-insert-str \u0026#34;？\u0026#34;))) (\u0026#34;!\u0026#34; . (lambda () (interactive) (mozc-insert-str \u0026#34;！\u0026#34;))))) :custom `((default-input-method . \u0026#34;japanese-mozc\u0026#34;) (mozc-helper-program-name . \u0026#34;mozc_emacs_helper\u0026#34;) (mozc-leim-title . \u0026#34;かな\u0026#34;)) :config (defun mozc-insert-str (str) (mozc-handle-event \u0026#39;enter) (insert str)) (defadvice toggle-input-method (around toggle-input-method-around activate) \u0026#34;Input method function in key-chord.el not to be nil.\u0026#34; (let ((input-method-function-save input-method-function)) ad-do-it (setq input-method-function input-method-function-save)))) Emacsから単語登録する Emacsで文章編集中にShellコマンドで mozc-tool を起動し、Emacsを閉じることなく単語登録できるようにしています。\n(leaf *cus-mozc-tool :bind ((\u0026#34;s-t\u0026#34; . my:mozc-dictionary-tool) (\u0026#34;s-d\u0026#34; . my:mozc-word-regist)) :init (defun my:mozc-dictionary-tool () \u0026#34;Open `mozc-dictipnary-tool\u0026#39;.\u0026#34; (interactive) (compile \u0026#34;/usr/lib/mozc/mozc_tool --mode=dictionary_tool\u0026#34;) (delete-other-windows)) (defun my:mozc-word-regist () \u0026#34;Open `mozc-word-regist\u0026#39;.\u0026#34; (interactive) (compile \u0026#34;/usr/lib/mozc/mozc_tool --mode=word_register_dialog\u0026#34;) (delete-other-windows))) Mozc 辞書の共有 Linux環境でMozcを使うメリットは辞書の共有です。\n Emacs以外のコンテンツでも同じMozc辞書を使うのでEmacsから単語登録しておけば全てのコンテンツで有効になる。 辞書ファイルをDropboxなどのクラウドに置くことで複数のマシンで共有できる。  Dropboxで辞書を共有する やり方は簡単です。\n Dropboxに ~/Dropbox/mozc フォルダを新規作成します。 つぎに、~/.mozc フォルダーを ~/Dropboc/mozc/ へコピーします。 最後に、~/.mozc を削除してDropboxにコピーした .mozc のシンボリックファイルを ~/ へ貼り付けます。  makefile で自動化するなら次のようになるかと思います。\nmozc_copy: mkdir -p ~/Dropbox/mozc cp -r ~/.mozc/ ~/Dropbox/mozc/ test -L ~/.mozc || rm -rf ~/.mozc ln -vsfn ~/Dropbox/mozc/.mozc ~/.mozc 辞書共有の課題 Dropboxに保存された辞書ファイルを複数マシンで同時アクセスした場合、複製（競合コピー）がいっぱい作られるという問題があります。 Google Driveは大丈夫という情報もありますが試せてません。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/server/",
	"title": "2.4. server / emacsclient",
	"tags": [],
	"description": "",
	"content": " shell-command で emacsclient をよく使うので、Emacs起動時に server を起動させています。 重複起動させない設定です。  ;; Server start for emacs-client (leaf server :require t :config (unless (server-running-p) (server-start))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/",
	"title": "2.5. exec-path-from-shell",
	"tags": [],
	"description": "",
	"content": " exec-path-from-shell は、シェルに設定した PATH の情報を継承して exec-path や PATH を設定してくれます。 自分は、shell-commad や compile-command をよく使うので必須のパッケージです。  purcell/exec-path-from-shell: Make Emacs use the $PATH set up by the user\u0026rsquo;s shell\n(leaf exec-path-from-shell :ensure t :when (memq window-system \u0026#39;(mac ns x)) :hook (after-init-hook . exec-path-from-shell-initialize) :custom (exec-path-from-shell-check-startup-files . nil)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/uniquify/",
	"title": "2.6. uniguify",
	"tags": [],
	"description": "",
	"content": "ビルトインの uniquify は、同じバッファ名が開かれた場合に区別する設定です。\n(setq uniquify-buffer-name-style \u0026#39;post-forward-angle-brackets) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/core/global-keybind/",
	"title": "2.7. gloal key bind",
	"tags": [],
	"description": "",
	"content": "グローバルキーバインドを自分好みにカスタマイズしました。 前準備として以下を設定しておきます。\n クリップボードを使えるようにする  ;; Use the X11 clipboard (setq select-enable-clipboard t)  マウスで選択した領域を自動コピー マウスで選択すると，勝手にペーストボードにデータが流れます．  (setq mouse-drag-copy-region t) グローバルキーバインドをカスタマイズする  C-w は、kill-ring-save に割り当てられたものですが、region 選択されていないときは、一行削除になるようにカスタマイズしてます。 C-x k の kill-buffer は、yes/no 確認されるのが煩わしいので、確認なしの kill-this-buffer を愛用しています。  ;; Change global key bind (leaf cus-global-keybind :bind ((\u0026#34;M-w\u0026#34; . clipboard-kill-ring-save) (\u0026#34;C-w\u0026#34; . my:kill-whole-line-or-region) (\u0026#34;s-c\u0026#34; . clipboard-kill-ring-save) (\u0026#34;s-v\u0026#34; . clipboard-yank) (\u0026#34;M-/\u0026#34; . kill-this-buffer))) ;; Overwrite `C-w\u0026#39; to the whole-line-or-region (defun my:kill-whole-line-or-region () \u0026#34;If the region is active, to kill region. If the region is inactive, to kill whole line.\u0026#34; (interactive) (if (use-region-p) (clipboard-kill-region (region-beginning) (region-end)) (kill-whole-line))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/sequential-command/",
	"title": "3.1. sequential-command",
	"tags": [],
	"description": "",
	"content": "[sequential-command.el] バッファーの先頭と最終行への移動を簡単に sequential-command は、標準の C-a C-e を拡張し、バッファーの先頭と最終行への移動を簡単にしてくれます。\n https://github.com/HKey/sequential-command C-a を連続で打つことで行頭→ファイルの先頭→元の位置とカーソルが移動 C-e を連続で打つことで行末→ファイルの最終行→元の位置とカーソルが移動  地味ながら一度使うと便利すぎて止められません。\nMELPAからインストールできますが、私は HKey氏の改良版を el-get でインストールしました。\n(leaf sequential-command :doc \u0026#34;https://bre.is/6Xu4fQs6\u0026#34; :el-get HKey/sequential-command :config (leaf sequential-command-config :hook (emacs-startup-hook . sequential-command-setup-keys))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/other-window-or-sprit/",
	"title": "3.2. other-window-or-split",
	"tags": [],
	"description": "",
	"content": " other-window-or-split は、画面分割コマンド C-x 3 を拡張します。 画面分割されていないときは、左右分割して follow-mode dimmer-mode も ON にしています。（詳細後述） 画面移動だけなら C-c o でもいいですが，ワンアクションで分割と移動を賢くしてくれるので便利です。  (defun other-window-or-split () \u0026#34;With turn on dimmer.\u0026#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (bind-key \u0026#34;C-q\u0026#34; \u0026#39;other-window-or-split) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/jump-brace/",
	"title": "3.3. my:jump-brace",
	"tags": [],
	"description": "",
	"content": "my:jump-brace は、括弧の先頭と最後へ交互にポイント移動します。\n(defun my:jump-brace () \u0026#34;Jump to the corresponding parenthesis.\u0026#34; (interactive) (let ((c (following-char)) (p (preceding-char))) (if (eq (char-syntax c) 40) (forward-list) (if (eq (char-syntax p) 41) (backward-list) (backward-up-list))))) (bind-key \u0026#34;C-M-9\u0026#34; \u0026#39;my:jump-brace) 標準機能  C-M-SPC (mark-sexp) は，カーソル位置から順方向に選択． C-M-U (backward-up-list) は，一つ外のカッコの先頭にポイントを移す．  でも、上記標準機能はなにげに使いにくいです。\n"
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/mark-command/",
	"title": "3.4. my:exchange-point-and-mark",
	"tags": [],
	"description": "",
	"content": " my:exchange-point-and-mark は、直前の編集ポイントと現在のポイントとを行き来できる設定です。  (defun my:exchange-point-and-mark () \u0026#34;No mark active `exchange-point-and-mark\u0026#39;.\u0026#34; (interactive) (exchange-point-and-mark) (deactivate-mark))\t(bind-key \u0026#34;C-x C-x\u0026#34; \u0026#39;my:exchange-point-and-mark) 標準機能の C-u C-SPC でもマーク箇所を辿れます。 (setq set-mark-command-repeat-pop t) (setq mark-ring-max 32) (setq global-mark-ring-max 64) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/cursor/expand-region/",
	"title": "3.5. expand-region",
	"tags": [],
	"description": "",
	"content": "[expand-refion.el] カーソル位置を起点に選択範囲を賢く広げてくれる expand-region.el は、カーソル位置を起点として前後に選択範囲を広げてくれます。\n2回以上呼ぶとその回数だけ賢く選択範囲が広がりますが、2回目以降は設定したキーバインドの最後の一文字を連打すれば OKです。その場合、選択範囲を狭める時は - を押し， 0 を押せばリセットされます。\n(leaf expand-region :ensure t :bind (\u0026#34;C-@\u0026#34; . er/expand-region)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/font/",
	"title": "4.1. font setting",
	"tags": [],
	"description": "",
	"content": " GUI / CUI 共通で Cica を使っています。  Cicaフォントは、Hack、DejaVu Sans Mono、Rounded Mgen+、Noto Emoji等のフォントを組み合わせて調整をした、日本語の等幅フォントです。\n プログラミング用日本語等幅フォント Cica Think Pad を2台使っていますので、環境を取得して設定を変えています。  フォントの設定  メイン機（Thinkpad E590）とサブ機（Thinkpad X250）とでそれぞれに適した値を決めています。  (add-to-list \u0026#39;default-frame-alist \u0026#39;(font . \u0026#34;Cica-18\u0026#34;)) ;; for sub-machine (when (string-match \u0026#34;x250\u0026#34; (code-command-to-string \u0026#34;uname -n\u0026#34;)) (add-to-list \u0026#39;default-frame-alist \u0026#39;(font . \u0026#34;Cica-15\u0026#34;))) Cicaフォントのインストール   Linux 環境でのインストールの方法です。\n  オフィシャルページにある最新の Cica v5.03 は、 page-break-lines で表示が乱れます。\n   Cica-v5.0.1のダウンロードページから、 (Cica-v5.0.1.zip) をダウンロードします。 上記サイトの存続は怪しいので自分のサイトにも置いておきます。 Cica-v5.0.1.zip  zipファイルを展開します。  $ unzip Cica-v5.0.1.zip LICENSE.txtを確認し、ファイルを /usr/local/share/fonts/ または ~/.fonts/ にコピーします。  $ sudo cp Cica-{Bold,BoldItalic,Regular,RegularItalic}.ttf ~/.fonts/ $ sudo fc-cache -vf $ fc-list | grep Cica /home/minoru/.fonts/Cica-v5.0.1/Cica-Regular.ttf: Cica:style=Regular /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-Regular.ttf: Cica:style=Regular /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-RegularItalic.ttf: Cica:style=Italic /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-Bold.ttf: Cica:style=Bold /home/minoru/.fonts/Cica-v5.0.1/Cica-BoldItalic.ttf: Cica:style=Bold Italic /home/minoru/.fonts/Cica-v5.0.1/Cica-Bold.ttf: Cica:style=Bold /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-BoldItalic.ttf: Cica:style=Bold Italic /home/minoru/.fonts/Cica-v5.0.1/Cica-RegularItalic.ttf: Cica:style=Italic "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/hl-line/",
	"title": "4.2. hl-line-mode",
	"tags": [],
	"description": "",
	"content": "ビルトインの hl-line-mode は、カーソル行に色をつける設定です。\n http://murakan.cocolog-nifty.com/blog/2009/01/emacs-tips-1d45.html https://www.emacswiki.org/emacs/highlight-current-line.el  機能別にhl-line のON/OFF や色を変えたりという設定もできますが、 私の場合は、シンプルに global 設定して色は theme に依存というスタイルです。\n(global-hl-line-mode 1) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/blink-cursor/",
	"title": "4.3. blink-cursor-mode",
	"tags": [],
	"description": "",
	"content": " blink-cursor-mode を設定してカーソルの点滅を制御します。  以下の例では、入力が止まってから 10 秒後に 0.3 秒間隔で点滅します。次に入力が始まるまで点滅が続きます．\n(setq blink-cursor-blinks 0) (setq blink-cursor-interval 0.3) (setq blink-cursor-delay 10) (add-hook \u0026#39;emacs-startup-hook . blink-cursor-mode) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/ivy-format/",
	"title": "4.4. ivy-format-function-arrow",
	"tags": [],
	"description": "",
	"content": " ivy-mode の選択行をアイコンで強調する設定です。  (defun my:ivy-format-function-arrow (cands) \u0026#34;Transform into a string for minibuffer with CANDS.\u0026#34; (ivy--format-function-generic (lambda (str) (concat (if (display-graphic-p) (all-the-icons-octicon \u0026#34;chevron-right\u0026#34; :height 0.8 :v-adjust -0.05) \u0026#34;\u0026gt;\u0026#34;) (propertize \u0026#34; \u0026#34; \u0026#39;display `(space :align-to 2)) (ivy--add-face str \u0026#39;ivy-current-match))) (lambda (str) (concat (propertize \u0026#34; \u0026#34; \u0026#39;display `(space :align-to 2)) str)) cands \u0026#34;\\n\u0026#34;)) (setq ivy-format-functions-alist \u0026#39;((t . my:ivy-format-function-arrow))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/paren/",
	"title": "4.5. pare",
	"tags": [],
	"description": "",
	"content": "(leaf paren :hook (after-init-hook . show-paren-mode) :custom `((show-paren-style . \u0026#39;parenthesis) (show-paren-when-point-inside-paren . t) (show-paren-when-point-in-periphery . t))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/rainbow-delimiters/",
	"title": "4.6. rainbow-delimiters",
	"tags": [],
	"description": "",
	"content": "(leaf rainbow-delimiters :ensure t :hook (prog-mode-hook . rainbow-delimiters-mode)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/rainbow/",
	"title": "4.7. rainbow-mode",
	"tags": [],
	"description": "",
	"content": " rainbow-mode.el は red, green などの色名や #aabbcc といったカラーコードから実際の色を表示するマイナーモードです。 常時表示しているとうざいときもあるので、global 設定しないで必要なときだけ使えるようにしています。  (leaf rainbow-mode :ensure t :bind (\u0026#34;C-c r\u0026#34; . rainbow-mode)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/volatile-highlights/",
	"title": "4.8. volatile-highlight",
	"tags": [],
	"description": "",
	"content": " volatile-highlights.el は、コピペした領域を強調します。 下記の設定は、コピペ直後の数秒に限定してコピペした領域をフラッシングさせます。  (leaf volatile-highlights :ensure t :hook (after-init-hook . volatile-highlights-mode) :config (when (fboundp \u0026#39;pulse-momentary-highlight-region) (defun my:vhl-pulse (beg end \u0026amp;optional _buf face) \u0026#34;Pulse the changes.\u0026#34; (pulse-momentary-highlight-region beg end face)) (advice-add #\u0026#39;vhl/.make-hl :override #\u0026#39;my:vhl-pulse))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/higlight/whitespace/",
	"title": "4.9. whitespace",
	"tags": [],
	"description": "",
	"content": "(leaf whitespace :ensure t :bind (\u0026#34;C-c C-c\u0026#34; . my:cleanup-for-spaces) :hook (prog-mode-hook . my:enable-trailing-mode) :custom (show-trailing-whitespace . nil) :config (defun my:enable-trailing-mode () \u0026#34;Show tail whitespace.\u0026#34; (setq show-trailing-whitespace t)) (defun my:cleanup-for-spaces () \u0026#34;Remove contiguous line breaks at end of line + end of file.\u0026#34; (interactive) (delete-trailing-whitespace) (save-excursion (save-restriction (widen) (goto-char (point-max)) (delete-blank-lines))))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/calendar/",
	"title": "7.. calendar",
	"tags": [],
	"description": "",
	"content": "6.4. [japanese-holidays] カレンダーをカラフルにする ビルドインの holidays と japanese-holidays.elを使います。土日祝日に色を着けます。土曜日と日曜祝日で異なる配色にできます。\n(leaf calendar :leaf-defer t :bind ((\u0026#34;\u0026lt;f7\u0026gt;\u0026#34; . calendar) (:calendar-mode-map (\u0026#34;\u0026lt;f7\u0026gt;\u0026#34; . calendar-exit))) :config (leaf japanese-holidays :ensure t :require t :hook ((calendar-today-visible-hook . japanese-holiday-mark-weekend) (calendar-today-invisible-hook . japanese-holiday-mark-weekend) (calendar-today-visible-hook . calendar-mark-today)) :config (setq calendar-holidays (append japanese-holidays holiday-local-holidays holiday-other-holidays)) (setq calendar-mark-holidays-flag t))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/prescient/",
	"title": "7.. calendar",
	"tags": [],
	"description": "",
	"content": "6.13. [prescient.el] リスト項目の並び替えとイニシャル入力機能（ivy and company） コマンド履歴を保存、コマンドのイニシャル入力を可能にする。\n(leaf prescient :ensure t :hook (after-init-hook . prescient-persist-mode) :custom `((prescient-aggressive-file-save . t) (prescient-save-file . \u0026quot;~/.emacs.d/tmp/prescient-save\u0026quot;)) :init (with-eval-after-load 'prescient (leaf ivy-prescient :ensure t :global-minor-mode t) (leaf company-prescient :ensure t :global-minor-mode t))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/diff-hl/",
	"title": "7.. diff-hl",
	"tags": [],
	"description": "",
	"content": "6.3. [diff-hl] 編集差分をフレーム端で視覚化 編集差分の視覚化は、元々 git-gutter が提供している機能です。しかし有効にするとフレームの幅が若干広がってしまうなどの不便さがあったので diff-hl に乗り換えました。\n(leaf diff-hl :ensure t :hook ((after-init-hook . global-diff-hl-mode) (after-init-hook . diff-hl-margin-mode))) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/imenu/",
	"title": "7.. imenu-list",
	"tags": [],
	"description": "",
	"content": "6.12. [imenu-list] サイドバー的にファイル内容の目次要素を表示 @takaxpさんの改良版/imenu-list を使ってます。\n(leaf imenu-list :ensure t :bind (\u0026quot;\u0026lt;f2\u0026gt;\u0026quot; . imenu-list-smart-toggle) :custom `((imenu-list-size . 30) (imenu-list-position . 'left) (imenu-list-focus-after-activation . t))) counsel-css.el を導入すると便利です。\n(leaf counsel-css :ensure t :hook (css-mode-hook . counsel-css-imenu-setup)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/toggle-fullscreen/",
	"title": "7.. toggle-fullscreen",
	"tags": [],
	"description": "",
	"content": "(global-set-key \u0026#34;\u0026lt;f11\u0026gt;\u0026#34; \u0026#39;toggle-fullscreen\u0026#39;) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/which-key/",
	"title": "7.. which-key",
	"tags": [],
	"description": "",
	"content": "[which-key] キーバインドの選択肢をポップアップする guide-key.el の後発、ディスパッチャが見やすく直感的でとても使いやすい。\n(leaf which-key :ensure t :hook (after-init-hook . which-key-mode) :custom (which-key-max-description-length . 40)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://minorugh.github.io/.emacs.d/display/display_01/",
	"title": "display_01",
	"tags": [],
	"description": "",
	"content": "5. 編集サポート / 入力補助 ファイル編集や入力補助の設定をまとめている。\n5.1. 矩形編集/連番入力 24.4 からは、rectangle-mark-mode が使えるようになり C-x SPC を押下すると矩形モードに入り直感的に矩形選択ができる。\n標準の rect.el に以下の機能が実装されている。\n|矩形切り取り|\tC-x r k | |矩形削除\t| C-x r d | |矩形貼り付け|\tC-x r y | |矩形先頭に文字を挿入|\tC-x r t | |矩形を空白に変換する|\tC-x r c |\n5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。\n(leaf markdown-mode :ensure t :mode (\u0026#34;\\\\.md\\\\\u0026#39;\u0026#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-emacs-lisp-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。\nhttps://github.com/shime/emacs-livedown\nnpmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。\n$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。\n(leaf emacs-livedown :el-get shime/emacs-livedown :bind ((\u0026#34;C-c C-c p\u0026#34; . livedown-preview) (\u0026#34;C-c C-c k\u0026#34; . livedown-kill))) 5.3. viewモード 特定の拡張子に対して常に view モードで開きたいときやgzされた emacs-lisp ソースを見るときに view-mode を使います。\n下記の設定では、my:auto-view-dirs に追加したディレクトリのファイルを開くと view-mode が常に有効になります．\n(leaf view :hook ((find-file-hook . my:auto-view) (server-visit-hook . my:unlock-view-mode)) :chord (\u0026#34;::\u0026#34; . view-mode) :bind (:view-mode-map (\u0026#34;h\u0026#34; . backward-char) (\u0026#34;l\u0026#34; . forward-char) (\u0026#34;a\u0026#34; . beginning-of-buffer) (\u0026#34;e\u0026#34; . end-of-buffer) (\u0026#34;w\u0026#34; . forward-word) (\u0026#34;b\u0026#34; . scroll-down) (\u0026#34;c\u0026#34; . kill-ring-save) (\u0026#34;r\u0026#34; . xref-find-references) (\u0026#34;RET\u0026#34; . xref-find-definitions) (\u0026#34;x\u0026#34; . my:view-del-char) (\u0026#34;y\u0026#34; . my:view-yank) (\u0026#34;d\u0026#34; . my:view-kill-region) (\u0026#34;u\u0026#34; . my:view-undo) (\u0026#34;m\u0026#34; . magit-status) (\u0026#34;g\u0026#34; . my:google) (\u0026#34;s\u0026#34; . swiper-region) (\u0026#34;%\u0026#34; . my:jump-brace) (\u0026#34;@\u0026#34; . counsel-mark-ring) (\u0026#34;n\u0026#34; . my:org-view-next-heading) (\u0026#34;p\u0026#34; . my:org-view-previous-heading) (\u0026#34;o\u0026#34; . other-window-or-split) (\u0026#34;G\u0026#34; . end-of-buffer) (\u0026#34;0\u0026#34; . my:delete-window) (\u0026#34;1\u0026#34; . my:delete-other-windows) (\u0026#34;2\u0026#34; . my:split-window-below) (\u0026#34;+\u0026#34; . text-scale-increase) (\u0026#34;-\u0026#34; . text-scale-decrease) (\u0026#34;/\u0026#34; . (lambda ()(interactive)(text-scale-set 0))) (\u0026#34;_\u0026#34; . kill-other-buffers) (\u0026#34;:\u0026#34; . View-exit-and-edit) (\u0026#34;i\u0026#34; . View-exit-and-edit) (\u0026#34;]\u0026#34; . winner-undo) (\u0026#34;[\u0026#34; . winner-redo) (\u0026#34;.\u0026#34; . hydra-view/body)) :init ;; Specific extension / directory (defvar my:auto-view-regexp \u0026#34;\\\\.php\\\\|\\\\.pl\\\\|\\\\.el.gz?\\\\|\\\\.tar.gz?\\\\\u0026#39;\u0026#34;) ;; Specific directory (defvar my:auto-view-dirs nil) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;~/src/\u0026#34;) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;~/Dropbox/GH/\u0026#34;) (add-to-list \u0026#39;my:auto-view-dirs \u0026#34;/scp:xsrv:/home/minorugh/\u0026#34;) (defun my:auto-view () \u0026#34;Open a file with view mode.\u0026#34; (when (file-exists-p buffer-file-name) (when (and my:auto-view-regexp (string-match my:auto-view-regexp buffer-file-name)) (view-mode 1)) (dolist (dir my:auto-view-dirs) (when (eq 0 (string-match (expand-file-name dir) buffer-file-name)) (view-mode 1))))) (defun my:unlock-view-mode () \u0026#34;Unlock view mode with git commit.\u0026#34; (when (string-match \u0026#34;COMMIT_EDITMSG\u0026#34; buffer-file-name) (view-mode 0)))) view-mode のときにモードラインの色を変えるのは viewer.el を使うと設定が簡単です。\n;; Change-modeline-color (leaf viewer :ensure t :hook (view-mode-hook . viewer-change-modeline-color-setup) :custom `((viewer-modeline-color-view . \u0026#34;#852941\u0026#34;) (viewer-modeline-color-unwritable . \u0026#34;#2F6828\u0026#34;))) view-mode からでも簡単な編集ができるように vim like なコマンドをいくつか作りました。\n(with-eval-after-load \u0026#39;view ;; save-buffer no message (defun my:save-buffer () \u0026#34;With clear Wrote message.\u0026#34; (interactive) (save-buffer) (message nil)) ;; Like as \u0026#39;x\u0026#39; of vim (defun my:view-del-char () \u0026#34;Delete charactor in view mode.\u0026#34; (interactive) (view-mode 0) (delete-char 1) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;dd\u0026#39; of vim (defun my:view-kill-region () \u0026#34;If the region is active, to kill region. If the region is inactive, to kill whole line.\u0026#34; (interactive) (view-mode 0) (if (use-region-p) (kill-region (region-beginning) (region-end)) (kill-whole-line)) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;u\u0026#39; of vim (defun my:view-undo () \u0026#34;Undo in view mode.\u0026#34; (interactive) (view-mode 0) (undo) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;y\u0026#39; of vim (defun my:view-yank () \u0026#34;Yank in view mode.\u0026#34; (interactive) (view-mode 0) (yank) (my:save-buffer) (view-mode 1)) ;; Like as \u0026#39;%\u0026#39; of vim (defun my:jump-brace () \u0026#34;Jump to the corresponding parenthesis.\u0026#34; (interactive) (let ((c (following-char)) (p (preceding-char))) (if (eq (char-syntax c) 40) (forward-list) (if (eq (char-syntax p) 41) (backward-list) (backward-up-list))))) (defun my:org-view-next-heading () \u0026#34;Org-view-next-heading.\u0026#34; (interactive) (if (and (derived-mode-p \u0026#39;org-mode) (org-at-heading-p)) (org-next-visible-heading 1) (next-line))) (defun my:org-view-previous-heading () \u0026#34;Org-view-previous-heading.\u0026#34; (interactive) (if (and (derived-mode-p \u0026#39;org-mode) (org-at-heading-p)) (org-previous-visible-heading 1) (previous-line)))) 5.4. web/htmlモード HTML編集をするならweb-mode がお勧めなのですが、私の場合あまり使っていません。\n出来上がったHTMLの内容を確認したり部分的に変更したり\u0026hellip;という程度の使い方です。\n(leaf web-mode :ensure t :mode (\u0026#34;\\\\.js?\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.html?\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.php?\\\\\u0026#39;\u0026#34;) :custom `((web-mode-markup-indent-offset . 2) (web-mode-css-indent-offset . 2) (web-mode-emacs-lisp-indent-offset . 2))) 5.5. [darkroom-mode] 執筆モード darkroom.el は、画面の余計な項目を最小限にして、文章の執筆に集中できるようにするパッケージです。\nhttps://github.com/joaotavora/darkroom\n[F12] キーで IN/OUT をトグルしています。 darkroom-mode から抜けるときは、revert-buffer で再読込してもとに戻します。\nyes/no確認を聞かれるのが煩わしいので my:revery-buffer-no-confirm の関数を作りました。\n(leaf darkroom :ensure t :bind ((\u0026#34;\u0026lt;f12\u0026gt;\u0026#34; . my:darkroom-in) (:darkroom-mode-map (\u0026#34;\u0026lt;f12\u0026gt;\u0026#34; . my:darkroom-out))) :config (defun my:darkroom-in () \u0026#34;Enter to the `darkroom-mode\u0026#39;.\u0026#34; (interactive) (view-mode 0) (diff-hl-mode 0) (display-line-numbers-mode 0) (darkroom-tentative-mode 1) (setq-local line-spacing 0.4)) (defun my:darkroom-out () \u0026#34;Returns from `darkroom-mode\u0026#39;to the previous state.\u0026#34; (interactive) (my:linespacing) (darkroom-tentative-mode 0) (display-line-numbers-mode 1) (my:revert-buffer-no-confirm)) (defun my:revert-buffer-no-confirm () \u0026#34;Revert buffer without confirmation.\u0026#34; (interactive) (revert-buffer t t))) 5.6. [yatex] YaTexで LaTex編集 yatex.el は、Emacsの上で動作する LaTeX の入力支援環境です。\nごく一般的な設定例ですが、参考になるとしたら dviprint-command-format に dvpd.sh というスクリプトを設定して、YateX.lpr コマンドでPDF作成 → プレビューまでの手順を一気に出来るように自動化している点でしょうか。\n(leaf yatex :ensure t :mode (\u0026#34;\\\\.tex\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.sty\\\\\u0026#39;\u0026#34; \u0026#34;\\\\.cls\\\\\u0026#39;\u0026#34;) :custom `((tex-command . \u0026#34;platex\u0026#34;) (dviprint-command-format . \u0026#34;dvpd.sh %s\u0026#34;) (YaTeX-kanji-emacs-lisp . nil) (YaTeX-latex-message-emacs-lisp . \u0026#39;utf-8) (YaTeX-default-pop-window-height . 15)) :config (leaf yatexprc :bind ((\u0026#34;M-c\u0026#34; . YaTeX-typeset-buffer) (\u0026#34;M-v\u0026#34; . YaTeX-lpr)))) YaTeX-lpr は、dviprint-command-format を呼び出すコマンドです。\ndviファイルから dvipdfmx で PDF作成したあと、ビューアーを起動させて表示させるところまでをバッチファイルに書き、chmod +x dvpd.sh  として実行権限を付与してからPATHの通ったところに置きます。私は、/usr/loca/bin に置きました。\n[dvpd.sh]\n#!/bin/emacs-lisp name=$1 dvipdfmx $1 \u0026amp;\u0026amp; evince ${name%.*}.pdf # Delete unnecessary files rm *.au* *.dv* *.lo* 上記の例では、ビューアーに Linux の evince を設定していますが、Mac の場合は、下記のようになるかと思います。\ndvipdfmx $1 \u0026amp;\u0026amp; open -a Preview.app ${name%.*}.pdf 5.7. [yasunippet] Emacs用のテンプレートシステム テンプレート挿入機能を提供してくれるやつです。\n(leaf yasnippet :ensure t :hook (after-init-hook . yas-global-mode) :config (leaf yasnippet-snippets :ensure t)) 以下の設定を追加するとcompany-mode と連携してとても使いやすくなる。\n(defvar company-mode/enable-yas t \u0026#34;Enable yasnippet for all backends.\u0026#34;) (defun company-mode/backend-with-yas (backend) (if (or (not company-mode/enable-yas) (and (listp backend) (member \u0026#39;company-yasnippet backend))) backend (append (if (consp backend) backend (list backend)) \u0026#39;(:with company-yasnippet)))) (setq company-backends (mapcar #\u0026#39;company-mode/backend-with-yas company-backends)) (bind-key \u0026#34;C-\u0026lt;tab\u0026gt;\u0026#34; \u0026#39;company-yasunippets) 5.8. [iedit] 選択領域を別の文字列に置き換える idet.el は、バッファー内の複数箇所を同時に編集するツールです。\n同じような機能のものは、複数あるようですが、わたしはこれを愛用しています。\n multi-cursors.el replace-from-region.el anzu.el  MELPAからpackage-installするだけで使えます。\n対象範囲を選択して C-; を押すとiedit-modeとなり、選択したキーワードが全てハイライト表示され、モードラインに押すとIedit:とキーワードの出現した回数が表示され、ミニバッファにもメッセージが表示されます。\nここで、ハイライトされた部分を編集すると、他のハイライトも同時に編集されるようになります。編集後、もう一度 C-; を押すと確定されiedet-modeを抜けます。\nかなりの頻度で使うので、Emacsでは使うことのない \u0026lt;insert\u0026gt; にキーバインドしています。\n(leaf iedit :ensure t :bind (\u0026#34;\u0026lt;insert\u0026gt;\u0026#34; . iedit-mode)) 5.9. [selected] リージョン選択時のアクションを制御 selected.el は、選択領域に対するスピードコマンドです。\nEmacsバッファーで領域を選択した後、バインドしたワンキーを入力するとコマンドが実行されます。 コマンドの数が増えてきたら、ヘルプ代わりに使える counsel-selected も便利そうです。\n(leaf selected :ensure t :hook (after-init-hook . selected-global-mode) :bind (:selected-keymap (\u0026#34;;\u0026#34; . comment-dwim) (\u0026#34;c\u0026#34; . clipboard-kill-ring-save) (\u0026#34;s\u0026#34; . swiper-thing-at-point) (\u0026#34;t\u0026#34; . google-translate-auto) (\u0026#34;T\u0026#34; . chromium-translate) (\u0026#34;W\u0026#34; . my:weblio) (\u0026#34;k\u0026#34; . my:koujien) (\u0026#34;e\u0026#34; . my:eijiro) (\u0026#34;g\u0026#34; . my:google))) 5.10. [selected] browse-urlで検索サイトで開く 検索結果を browse-url で表示させるユーザーコマンドは、検索 urlのフォーマットとさえわかれば、パッケージツールに頼らずともお好みのマイコマンドを作成できます。\n(defun my:koujien (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://sakura-paris.org/dict/広辞苑/prefix/%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:weblio (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://www.weblio.jp/content/%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:eijiro (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://eow.alc.co.jp/%s/UTF-8/\u0026#34; (upcase (url-hexify-string str))))) (defun my:google (str) (interactive (list (my:get-region nil))) (browse-url (format \u0026#34;https://www.google.com/search?hl=ja\u0026amp;q=%s\u0026#34; (upcase (url-hexify-string str))))) (defun my:get-region (r) \u0026#34;Get search word from region.\u0026#34; (buffer-substring-no-properties (region-beginning) (region-end))) 5.11. [selected] IME のオン・オフを自動制御する selectedコマンドを選択するときは、IMEをOffにしないといけないのですがこれを自動でさせます。\n領域を選択し始める時に IMEをオフにして、コマンド発行後に IMEを元に戻すという例が、 @takaxp さんの Qiitaの記事 にあったので、私の環境（emacs-mozc ）にあうように設定したら、すんなり動いてくれました。感謝！\n(leaf *cus-selected :hook ((activate-mark-hook . my:activate-selected) (activate-mark-hook . (lambda () (setq my:ime-flag current-input-method) (my:ime-off))) (deactivate-mark-hook . (lambda () (unless (null my:ime-flag) (my:ime-on))))) :init ;; Control mozc when seleceted (defun my:activate-selected () (selected-global-mode 1) (selected--on) (remove-hook \u0026#39;activate-mark-hook #\u0026#39;my:activate-selected)) (add-hook \u0026#39;activate-mark-hook #\u0026#39;my:activate-selected) (defun my:ime-on () (interactive) (when (null current-input-method) (toggle-input-method))) (defun my:ime-off () (interactive) (inactivate-input-method)) (defvar my:ime-flag nil) (add-hook \u0026#39;activate-mark-hook #\u0026#39;(lambda () (setq my:ime-flag current-input-method) (my:ime-off))) (add-hook \u0026#39;deactivate-mark-hook #\u0026#39;(lambda () (unless (null my:ime-flag) (my:ime-on))))) 5.12. [swiper-migemo] ローマ字入力で日本語を検索 avy-migemo-e.g.swiper.el を使って出来ていたのですが、２年ほど前から更新が止まってしまっていて動きません。\nつい最近、avy-migemo を使わない swiper-migemoを GitHubで見つけたので試した処、機嫌よく動いてくれています。 MELPAにはアップされていないみたいなので el-get で取得しています。\n(leaf swiper-migemo :el-get tam17aki/swiper-migemo :global-minor-mode t) 5.13. [smartparent] 対応する括弧の挿入をアシスト smartparens.el の設定がいまいちよくわからず、とりあえず次のように設定して今のところ機嫌よく働いている。\n(leaf smartparens :ensure t :require smartparens-config :hook (prog-mode-hook . turn-on-smartparens-mode) :config (smartparens-global-mode t)) 5.14. [key-chord.el] 同時押しでキーバインド  同時押しというキーバインドを提供してくれるやつ 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。  (leaf key-chord :ensure t :hook (after-init-hook . key-chord-mode) :chord ((\u0026#34;df\u0026#34; . counsel-descbinds) (\u0026#34;l;\u0026#34; . init-loader-show-log) (\u0026#34;@@\u0026#34; . howm-list-all) (\u0026#34;jk\u0026#34; . open-junk-file)) :custom `((key-chord-two-keys-delay . 0.25) (key-chord-safety-interval-backward . 0.1) (key-chord-safety-interval-forward . 0.15))) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。\n改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動にも使っている上に、よく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。\n5.15. [fontawesome] fontawesome utility fontawesome.el は、Emacs での fontawesome の入力が簡単に出来るユーティリティです。helm や ivy とも勝手に連携してくれる。\n(leaf FontAwesome :ensure t :bind (\u0026#34;s-a\u0026#34; . councel-fontawesome)) "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/",
	"title": "minoru&#39;s Emacs Configuration",
	"tags": [],
	"description": "",
	"content": "はじめに  ここは @minoruGH の Emacs設定ファイルの一部を解説しているページです。 https://github.com/minorugh/.emacs.d/ から Hugo を使ってGithub pages にWebサイトを構築しています。 本ドキュメントは、@takaxpさんが公開されている takaxp.github.io/ の記事を下敷きにした模倣版です。 執筆用途に特化してカスタマイズしていますので、コンセプトやキーバイドなどは極めて邪道思想になっています。  動作確認環境 以下の環境で使用しています。が、動作を保証するものではありません。\n Debian 11.4 86_64 GNU/Linux 自分でビルドした Emacs 27.2.50  デレクトリ構成 設定ファイルの構成は下記のとおりです。\n~/.emacs.d │ ├── el-get/ ├── elpa/ ├── inits/ │ ├── 00_base.el │ ├── 01_dashboard.el │ ├── ... │ ├── 90_eshell.el │ └── 99_chromium.el ├── snippets/ ├── tmp/ ├── early-init.el ├── init.el └── mini-init.el "
},
{
	"uri": "https://minorugh.github.io/.emacs.d/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]