<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>minoru&#39;s Emacs Configuration</title>
    <link>https://minorugh.github.io/.emacs.d/</link>
    <description>Recent content on minoru&#39;s Emacs Configuration</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language><atom:link href="https://minorugh.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1. eary-init.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/eary-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/eary-init/</guid>
      <description>early-init.el は、Emacs27から導入されました。 https://github.com/minorugh/dotfiles/blob/main/.emacs.d/early-init.el  init.el でパッケージシステムやGUIの初期化が実行される前にロードされるので、UI関係や package-enable-at-startup のようなパッケージ初期化プロセスに影響を与える変数をカスタマイズできます。
GCを減らす GC の閾値を最大にしておくことで GC を実質止めることができます。とりあえず書いておけば速くなる系なのでおすすめです。
;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) eary-init.el の先頭に書くことが重要です。
Package の初期化を抑制する Emacs27では、(package-initialize) が 2回実行されます。 (1回は init ファイルの評価中に、もう 1回は Emacs が initファイルの読み取りを終了した後に)。
1回目を抑制するために以下を eary-init.el に記述することで初期化が少し早くなります。
;; For slightly faster startup (setq package-enable-at-startup nil) 常に最新のバイトコードをロードする ;; Always load newest byte code (setq load-prefer-newer t) フレームのサイズ変更を禁止する ;; Inhibit resizing frame (setq frame-inhibit-implied-resize t) これらを無効にする方が速い (初期化される前) ;; Faster to disable these here (before they&amp;#39;ve been initialized) (push &amp;#39;(fullscreen .</description>
    </item>
    
    <item>
      <title>1.2. Magic File Name を一時的に無効にする</title>
      <link>https://minorugh.github.io/.emacs.d/startup/magick-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/magick-file/</guid>
      <description>Magic File Name を一時的に無効にすることで、起動時間を短縮できます。 GC設定とともに設定ファイル読み込み後に正常値に戻します。  ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover file name handlers.&amp;#34; (setq file-name-handler-alist (delete-dups (append file-name-handler-alist old-file-name-handler-alist))))))) ;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover GC values after startup.&amp;#34; (setq gc-cons-threshold 800000))) ※ init.el の先頭に書きます。</description>
    </item>
    
    <item>
      <title>1.3. leaf.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/leaf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/leaf/</guid>
      <description>これまで use-pacage.el を使っていましたが、 @conao3 さんの開発された leaf.el に触発されて全面的に書き直しました。
 Emacs入門から始めるleaf.el入門  (eval-and-compile (customize-set-variable &amp;#39;package-archives &amp;#39;((&amp;#34;org&amp;#34; . &amp;#34;https://orgmode.org/elpa/&amp;#34;) (&amp;#34;melpa&amp;#34; . &amp;#34;https://melpa.org/packages/&amp;#34;) (&amp;#34;gnu&amp;#34; . &amp;#34;https://elpa.gnu.org/packages/&amp;#34;))) (package-initialize) (unless (package-installed-p &amp;#39;leaf) (package-refresh-contents) (package-install &amp;#39;leaf)) (leaf leaf-keywords :ensure t :init (leaf hydra :ensure t) (leaf el-get :ensure t) :config (leaf-keywords-init))) </description>
    </item>
    
    <item>
      <title>1.4. init-loader.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/init-loader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/init-loader/</guid>
      <description> emacs-jp/init-loader:Loader of configuration files.  設定ファイル群のローダーです。 指定されたディレクトリから構成ファイルをロードします。これにより、構成を分類して複数のファイルに分けることができます。
init-loader には、エラーが出た設定ファイルは読み込まれない&amp;hellip;という特徴があり原因究明がしやすくなるというメリットがある。またログの出力機能を備えていることもメリットとして挙げられる。
起動時間が犠牲になるということで敬遠される向きもあるが微々たるもので、恩恵のほうが遥かに大きい。
(leaf init-loader :ensure t :config (custom-set-variables &amp;#39;(init-loader-show-log-after-init &amp;#39;error-only)) (init-loader-load)) </description>
    </item>
    
    <item>
      <title>1.5. 最小限の emacs起動設定</title>
      <link>https://minorugh.github.io/.emacs.d/startup/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/test/</guid>
      <description>最小限の emacs を起動させるための設定です。  test.el は、 新しいパッケージを試したり設定をテストしたり、エラー等で Emacsが起動しない場合などに使用します。
以下を .zshrc または .coderc に記述し反映させたのち、シェルから eq と入力することで起動することがでます。
alias eq = &amp;#39;emacs -q -l ~/.emacs.d/test.el&amp;#39; ファイルの PATH は、ご自分の環境に応じて修正が必要です。</description>
    </item>
    
    <item>
      <title>2.1. 言語と文字コード</title>
      <link>https://minorugh.github.io/.emacs.d/core/encode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/encode/</guid>
      <description>シンプルにこれだけです。
(set-language-environment &amp;#34;Japanese&amp;#34;) (prefer-coding-system &amp;#39;utf-8) </description>
    </item>
    
    <item>
      <title>2.2. フォント設定</title>
      <link>https://minorugh.github.io/.emacs.d/core/font/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/font/</guid>
      <description>GUI / CUI 共通で Cica を使っています。  Cicaフォントは、Hack、DejaVu Sans Mono、Rounded Mgen+、Noto Emoji等のフォントを組み合わせて調整をした、日本語の等幅フォントです。
 プログラミング用日本語等幅フォント Cica  Cicaフォントのインストール   Linux 環境でのインストールの方法です。
  オフィシャルページにある最新の Cica v5.03 は、 page-break-lines で表示が乱れます。
   Cica-v5.0.1のダウンロードページから、 (Cica-v5.0.1.zip) をダウンロードします。 上記サイトの存続は怪しいので自分のサイトにも置いておきます。 Cica-v5.0.1.zip  zipファイルを展開します。  $ unzip Cica-v5.0.1.zip LICENSE.txtを確認し、ファイルを /usr/local/share/fonts/ または ~/.fonts/ にコピーします。  $ sudo cp Cica-{Bold,BoldItalic,Regular,RegularItalic}.ttf ~/.fonts/ $ sudo fc-cache -vf $ fc-list | grep Cica /home/minoru/.fonts/Cica-v5.0.1/Cica-Regular.ttf: Cica:style=Regular /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-Regular.ttf: Cica:style=Regular /home/minoru/.fonts/Cica-v5.0.1/noemoji/Cica-RegularItalic.ttf: Cica:style=Italic /home/minoru/.</description>
    </item>
    
    <item>
      <title>2.3. 日本語入力の設定</title>
      <link>https://minorugh.github.io/.emacs.d/core/mozc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/mozc/</guid>
      <description>Debian11 にインストールした Emacs上で emacs-mozc を使っています。 debian でのインストール手順は以下の通り。  $ sudo apt-get install fcitx-mozc emacs-mozc Emacsをソースからビルドするときに --without-xim しなかったので、インライン XIMでも日本語入力ができてしまいます。 特に使い分けする必要もなく紛らわしいので .Xresources で XIM無効化の設定をしました。
! ~/.Xresources ! Emacs XIMを無効化 Emacs*useXIM: false 句読点などを入力したとき、わざわざ mozcに変換してもらう必要はないので以下を設定しておくことでワンアクションスピーディーになります。
(leaf mozc :ensure t :bind ((&amp;#34;&amp;lt;hiragana-katakana&amp;gt;&amp;#34; . toggle-input-method) (:mozc-mode-map (&amp;#34;,&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;、&amp;#34;))) (&amp;#34;.&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;。&amp;#34;))) (&amp;#34;?&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;？&amp;#34;))) (&amp;#34;!&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;！&amp;#34;))))) :custom `((default-input-method .</description>
    </item>
    
    <item>
      <title>2.4. Server 機能を使う</title>
      <link>https://minorugh.github.io/.emacs.d/core/server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/server/</guid>
      <description>;; Server start for emacs-client (leaf server :require t :config (unless (server-running-p) (server-start))) </description>
    </item>
    
    <item>
      <title>2.5. [exec-path-from-shell] 設定をシェルから継承する</title>
      <link>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</guid>
      <description> purcell/exec-path-from-shell: Make Emacs use the $PATH set up by the user&amp;rsquo;s shell  外部プログラムのサポートを得て動くパッケージは、設定の過程で「プログラムが見つからない」と怒られることがしばしばあります。 exec-path-from-shell は、シェルに設定した PATH の情報を継承して exec-path や PATH を設定してくれます。自分は、shell-commad や compile-command をよく使うので必須のパッケージです。
(leaf exec-path-from-shell :ensure t :when (memq window-system &amp;#39;(mac ns x)) :hook (after-init-hook . exec-path-from-shell-initialize) :custom (exec-path-from-shell-check-startup-files . nil)) </description>
    </item>
    
    <item>
      <title>2.6. [uniquify.el] 同じバッファ名が開かれた場合に区別する</title>
      <link>https://minorugh.github.io/.emacs.d/core/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/uniquify/</guid>
      <description>3.9. [uniquify.el] 同じバッファ名が開かれた場合に区別する ビルトインの uniquify を使います。モードラインの表示が変わります。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>2.7. グローバルキーバインド</title>
      <link>https://minorugh.github.io/.emacs.d/core/global-keybind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/global-keybind/</guid>
      <description>グローバルキーバインドを自分好みにカスタマイズしました。 前準備として以下を設定しておきます。
 クリップボードを使えるようにする  ;; Use the X11 clipboard (setq select-enable-clipboard t)  マウスで選択した領域を自動コピー マウスで選択すると，勝手にペーストボードにデータが流れます．  (setq mouse-drag-copy-region t) グローバルキーバインドをカスタマイズする  C-w は、kill-ring-save に割り当てられたものですが、region 選択されていないときは、一行削除になるようにカスタマイズしてます。 C-x k の kill-buffer は、yes/no 確認されるのが煩わしいので、確認なしの kill-this-buffer を愛用しています。  ;; Change global key bind (leaf cus-global-keybind :bind ((&amp;#34;M-w&amp;#34; . clipboard-kill-ring-save) (&amp;#34;C-w&amp;#34; . my:kill-whole-line-or-region) (&amp;#34;s-c&amp;#34; . clipboard-kill-ring-save) (&amp;#34;s-v&amp;#34; . clipboard-yank) (&amp;#34;M-/&amp;#34; . kill-this-buffer))) ;; Overwrite `C-w&amp;#39; to the whole-line-or-region (defun my:kill-whole-line-or-region () &amp;#34;If the region is active, to kill region.</description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://minorugh.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) (lisp-interaction-mode-hook dired-mode-hook). my:disable-modes) :bind (&amp;#34;&amp;lt;f9&amp;gt;&amp;#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () &amp;#34;Disable modes in scrtch buffer.&amp;#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0))) </description>
    </item>
    
    <item>
      <title>cursor</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/cursor_01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/cursor_01/</guid>
      <description>4. カーソル移動  文字移動、行移動、スクロールは、素直に上下左右の矢印キーとPgUp PgDn を使っています。  4.1. [sequential-command.el] バッファー内のカーソル移動  https://github.com/HKey/sequential-command  標準の C-a C-e を拡張し、バッファーの先頭と最終行への移動を簡単にしてくれます。
 C-a を連続で打つことで行頭→ファイルの先頭→元の位置とカーソルが移動 C-e を連続で打つことで行末→ファイルの最終行→元の位置とカーソルが移動  地味ながら一度使うと便利すぎて止められません。
MELPAから Installできますが、私は HKey氏の改良版を el-get でインストールしました。
(leaf sequential-command :doc &amp;#34;https://bre.is/6Xu4fQs6&amp;#34; :el-get HKey/sequential-command :config (leaf sequential-command-config :hook (emacs-startup-hook . sequential-command-setup-keys))) 4.2. ウインドウ間のカーソル移動 C-c o でもいいですが，ワンアクションで移動できるほうが楽なので、次のように双方向で使えるように設定しています．
画面分割されていないときは、左右分割して新しいウインドウに移動します。
(defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (bind-key &amp;#34;C-q&amp;#34; &amp;#39;other-window-or-split) 4.3. 対応する括弧を選択  C-M-SPC (mark-sexp) は，カーソル位置から順方向に選択． C-M-U (backward-up-list) は，一つ外のカッコの先頭にポイントを移す．  上記標準機能は使いにくいので my:jump-brace を定義しました。 括弧の先頭と最後へ交互にポイント移動します。</description>
    </item>
    
    <item>
      <title>dimmer</title>
      <link>https://minorugh.github.io/.emacs.d/buffer/dimmer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/buffer/dimmer/</guid>
      <description>[dimmer.el] 現在のバッファ以外の輝度を落とす takaxp.github.io の設定をそのままパクリました。 on/off できるのが快適です。
(leaf dimmer :ensure t :chord (&amp;#34;..&amp;#34; . my:toggle-dimmer) :config (defvar my:dimmer-mode 1) (setq dimmer-buffer-exclusion-regexps &amp;#39;(&amp;#34;^ \\*which-key\\|^ \\*LV\\|^ \\*.*posframe.*buffer.*\\*$&amp;#34;)) (setq dimmer-fraction 0.6) (defun my:toggle-dimmer () (interactive) (unless (one-window-p) (if (setq my:dimmer-mode (not my:dimmer-mode)) (dimmer-on) (dimmer-off)))) (defun dimmer-off () (dimmer-process-all) (dimmer-mode -1)) (defun dimmer-on () (when my:dimmer-mode (dimmer-mode 1) (dimmer-process-all)))) Sprit-window と連携させる dimmer-mode を global に設定すると多くのシーンでDisable対策の設定が必要になり面倒です。
下記の通り発想転換すれば呪縛から逃れることができます。
 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((&amp;#34;C-q&amp;#34; .</description>
    </item>
    
    <item>
      <title>display_01</title>
      <link>https://minorugh.github.io/.emacs.d/display/display_01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/display_01/</guid>
      <description>5. 編集サポート / 入力補助 ファイル編集や入力補助の設定をまとめている。
5.1. 矩形編集/連番入力 24.4 からは、rectangle-mark-mode が使えるようになり C-x SPC を押下すると矩形モードに入り直感的に矩形選択ができる。
標準の rect.el に以下の機能が実装されている。
|矩形切り取り|	C-x r k | |矩形削除	| C-x r d | |矩形貼り付け|	C-x r y | |矩形先頭に文字を挿入|	C-x r t | |矩形を空白に変換する|	C-x r c |
5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。
(leaf markdown-mode :ensure t :mode (&amp;#34;\\.md\\&amp;#39;&amp;#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-emacs-lisp-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。
https://github.com/shime/emacs-livedown
npmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。
$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。</description>
    </item>
    
    <item>
      <title>doom-modeline</title>
      <link>https://minorugh.github.io/.emacs.d/ui/doom-modeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/doom-modeline/</guid>
      <description>(leaf doom-modeline :ensure t :hook (after-init-hook . doom-modeline-mode) :custom (doom-modeline-icon . t) (doom-modeline-major-mode-icon . nil) (doom-modeline-minor-modes . nil) :config (line-number-mode 0) (column-number-mode 0) (doom-modeline-def-modeline &amp;#39;main &amp;#39;(bar window-number matches buffer-info remote-host buffer-position parrot selection-info) &amp;#39;(misc-info persp-name lsp github debug minor-modes input-method major-mode process vcs checker)) :init (leaf nyan-mode :ensure t :config (nyan-mode 1) (nyan-start-animation))) </description>
    </item>
    
    <item>
      <title>doom-thmes</title>
      <link>https://minorugh.github.io/.emacs.d/ui/doom-themes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/doom-themes/</guid>
      <description>(leaf doom-themes :ensure t :hook (after-init-hook . (lambda () (load-theme &#39;doom-dracula t))) :custom (doom-themes-enable-italic . nil) (doom-themes-enable-bold . nil) :config (doom-themes-neotree-config) (doom-themes-org-config)) </description>
    </item>
    
    <item>
      <title>sprit-window</title>
      <link>https://minorugh.github.io/.emacs.d/buffer/sprit-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/buffer/sprit-window/</guid>
      <description>Sprit-window との連携  同じバッファーを分割したときは、follow-mode にする。 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((&amp;#34;C-q&amp;#34; . other-window-or-split) (&amp;#34;C-x 2&amp;#34; . my:split-window-below) (&amp;#34;C-x 1&amp;#34; . my:delete-other-windows) (&amp;#34;C-x 0&amp;#34; . my:delete-window) (&amp;#34;&amp;lt;C-return&amp;gt;&amp;#34; . window-swap-states)) :init (defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (defun my:split-window-below () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (split-window-below) (follow-mode 1) (dimmer-mode 1)) (defun my:delete-window () &amp;#34;With turn off dimmer.&amp;#34; (interactive) (delete-window) (follow-mode -1) (dimmer-mode -1)) (defun my:delete-other-windows () &amp;#34;With turn off dimmer.</description>
    </item>
    
  </channel>
</rss>
