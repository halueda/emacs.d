<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>minoru&#39;s Emacs Configuration</title>
    <link>https://minorugh.github.io/.emacs.d/</link>
    <description>Recent content on minoru&#39;s Emacs Configuration</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language><atom:link href="https://minorugh.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>7.1. markdown-mode</title>
      <link>https://minorugh.github.io/.emacs.d/editing/markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/markdown/</guid>
      <description>5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。
(leaf markdown-mode :ensure t :mode (&amp;#34;\\.md\\&amp;#39;&amp;#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-code-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。
https://github.com/shime/emacs-livedown
npmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。
$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。
(leaf emacs-livedown :el-get shime/emacs-livedown :bind ((&amp;#34;C-c C-c p&amp;#34; . livedown-preview) (&amp;#34;C-c C-c k&amp;#34; . livedown-kill))) </description>
    </item>
    
    <item>
      <title>9.1. auto-save-buffer-enhanced</title>
      <link>https://minorugh.github.io/.emacs.d/history/auto-save-buffer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/auto-save-buffer/</guid>
      <description> auto-save-buffer-enhanced は、ファイルの自動保存機能を提供します。 kentaro/auto-save-buffer-enhanced.el: Provide file autosave in Emacs  ;; auto-save-buffers (leaf auto-save-buffers-enhanced :ensure t :custom `((auto-save-buffers-enhanced-exclude-regexps . &amp;#39;(&amp;#34;^/ssh:&amp;#34; &amp;#34;^/scp:&amp;#34; &amp;#34;/sudo:&amp;#34;)) (auto-save-buffers-enhanced-quiet-save-p . t) ;; Disable to prevent freeze in tramp-mode (auto-save-buffers-enhanced-include-only-checkout-path . nil)) :config (auto-save-buffers-enhanced t)) </description>
    </item>
    
    <item>
      <title>9.2. undo-fua</title>
      <link>https://minorugh.github.io/.emacs.d/history/undo-fu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/undo-fu/</guid>
      <description>8.3. [undo-fu] シンプルな undo/redo を提供 undo-fu はシンプルな undo/redo 機能を提供してくれるやつです。
昔はもっと色々できる undo-tree を使っていたけどそっちにバグがあるっぽいので乗り換えました。
(leaf undo-fu :ensure t :bind ((&amp;#34;C-_&amp;#34; . undo-fu-only-undo) (&amp;#34;C-/&amp;#34; . undo-fu-only-redo))) </description>
    </item>
    
    <item>
      <title>5.2. dimmer-mode</title>
      <link>https://minorugh.github.io/.emacs.d/frame/dimmer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/dimmer/</guid>
      <description>dimmer.el は、現在のバッファ以外の輝度を落とす機能を実現するためのパッケージです。  takaxp.github.io の設定をそのままパクリました。 ON/OFF できるのが快適です。
(leaf dimmer :ensure t :chord (&amp;#34;..&amp;#34; . my:toggle-dimmer) :config (defvar my:dimmer-mode 1) (setq dimmer-buffer-exclusion-regexps &amp;#39;(&amp;#34;^ \\*which-key\\|^ \\*LV\\|^ \\*.*posframe.*buffer.*\\*$&amp;#34;)) (setq dimmer-fraction 0.6) (defun my:toggle-dimmer () (interactive) (unless (one-window-p) (if (setq my:dimmer-mode (not my:dimmer-mode)) (dimmer-on) (dimmer-off)))) (defun dimmer-off () (dimmer-process-all) (dimmer-mode -1)) (defun dimmer-on () (when my:dimmer-mode (dimmer-mode 1) (dimmer-process-all)))) Sprit-window と連携させる dimmer-mode を global に設定すると多くのシーンでDisable対策の設定が必要になり面倒です。
下記の通り発想転換すれば呪縛から逃れることができます。
 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((&amp;#34;C-q&amp;#34; .</description>
    </item>
    
    <item>
      <title>7.2. veiw-mode</title>
      <link>https://minorugh.github.io/.emacs.d/editing/view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/view/</guid>
      <description>5.3. viewモード 特定の拡張子に対して常に view モードで開きたいときやgzされた elisp ソースを見るときに view-mode を使います。
下記の設定では、my:auto-view-dirs に追加したディレクトリのファイルを開くと view-mode が常に有効になります．
(leaf view :hook (find-file-hook . my:auto-view) (server-visit-hook . my:unlock-view-mode) :chord (&amp;#34;::&amp;#34; . view-mode) :bind (:view-mode-map (&amp;#34;h&amp;#34; . backward-char) (&amp;#34;l&amp;#34; . forward-char) (&amp;#34;a&amp;#34; . beginning-of-buffer) (&amp;#34;e&amp;#34; . end-of-buffer) (&amp;#34;w&amp;#34; . forward-word) (&amp;#34;b&amp;#34; . scroll-down) (&amp;#34;c&amp;#34; . kill-ring-save) (&amp;#34;r&amp;#34; . xref-find-references) (&amp;#34;RET&amp;#34; . xref-find-definitions) (&amp;#34;x&amp;#34; . my:view-del-char) (&amp;#34;y&amp;#34; . my:view-yank) (&amp;#34;d&amp;#34; . my:view-kill-region) (&amp;#34;u&amp;#34; . my:view-undo) (&amp;#34;m&amp;#34; . magit-status) (&amp;#34;g&amp;#34; .</description>
    </item>
    
    <item>
      <title>5.3. scrool-other-Window</title>
      <link>https://minorugh.github.io/.emacs.d/frame/scrool-other-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/scrool-other-window/</guid>
      <description>Scrool-other-Window は、deactive なwindowをスクロールさせるための設定です。
一画面のとき &amp;lt;next&amp;gt; / &amp;lt;prior&amp;gt; は、PgUp / PgDn として使うが、画面分割のときだけ other-Window に対応させている。 標準機能の C-v: scroll-uo-command / M-v: scroll-down-command を使い分ければ快適に二画面同時閲覧が可能となる。
(leaf *my:scroll-other-window :bind ((&amp;#34;&amp;lt;next&amp;gt;&amp;#34; . my:scroll-other-window) (&amp;#34;&amp;lt;prior&amp;gt;&amp;#34; . my:scroll-other-window-down)) :init (defun my:scroll-other-window () &amp;#34;If there are two windows, `scroll-other-window&amp;#39;.&amp;#34; (interactive) (when (one-window-p) (scroll-up)) (scroll-other-window)) (defun my:scroll-other-window-down () &amp;#34;If there are two windows, `scroll-other-window-down&amp;#39;.&amp;#34; (interactive) (when (one-window-p) (scroll-down)) (scroll-other-window-down))) </description>
    </item>
    
    <item>
      <title>7.3. all-the-icons</title>
      <link>https://minorugh.github.io/.emacs.d/display/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/all-the-icons/</guid>
      <description>all-the-icons.el を使うとバッファ内やモードライン、ミニバッファでアイコンを表示できるようになります。
 domtronn/all-the-icons.el: A utility package to collect various Icon Fonts and propertize them within Emacs.  初めて使うときはパッケージを使えるようにした後、M-x all-the-icons-install-fonts すると自動的にフォントがインストールされます。以下の設定では自動化しています。
(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) (lisp-interaction-mode-hook dired-mode-hook). my:disable-modes) :bind (&amp;#34;&amp;lt;f9&amp;gt;&amp;#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () &amp;#34;Disable modes in scrtch buffer.&amp;#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0))) all-the-icons-dired dired でファイルのアイコンを表示します。
 Emacs27以降、MELPA版は白色にしか表示されないので jtbm37/all-the-icons-dired をel-getでインストールしています。  (leaf all-the-icons-dired :el-get jtbm37/all-the-icons-dired :after doom-modeline :hook (dired-mode-hook . all-the-icons-dired-mode)) all-the-icons-ivy-rich ivy-mode でアイコン表示をします。</description>
    </item>
    
    <item>
      <title>7.3. line-spacing</title>
      <link>https://minorugh.github.io/.emacs.d/display/linespacing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/linespacing/</guid>
      <description>12.4 行間を制御する line-spacing 行間を制御する変数です。バッファローカルな変数なので、ミニバッファも含めて、各バッファの行間を個別に制御できます。
@takaxpさんのブログ記事 のによると、global で 0.3 以下に設定すると nil に戻せないという不具合があるとのことなので、Tipsをパクって以下のように設定をしました。
(defun my:linespacing () (unless (minibufferp) (setq-local line-spacing 0.2))) (add-hook &#39;buffer-list-update-hook #&#39;my:linespacing) my:linespacing はシンプルに、 global ではなく local 変数の line-spacing を書き換えます。 (minibufferp) で括っているのは、ミニバッファの行間を my:linespacing に左右されずに制御するためです。
darkroom-mode では、
(setq-local line-spacing 0.4) と行間を大きくするように設定していますが、dark-room からでるときに my:linespacing に戻しています。</description>
    </item>
    
    <item>
      <title>7.3. web-mode</title>
      <link>https://minorugh.github.io/.emacs.d/editing/web-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/web-mode/</guid>
      <description>[web-mode] HTML編集をサポート HTML編集をするならweb-mode がお勧めなのですが、私の場合あまり使っていません。
出来上がったHTMLの内容を確認したり部分的に変更したり&amp;hellip;という程度の使い方です。
(leaf web-mode :ensure t :mode (&amp;#34;\\.js?\\&amp;#39;&amp;#34; &amp;#34;\\.html?\\&amp;#39;&amp;#34; &amp;#34;\\.php?\\&amp;#39;&amp;#34;) :custom `((web-mode-markup-indent-offset . 2) (web-mode-css-indent-offset . 2) (web-mode-code-indent-offset . 2))) </description>
    </item>
    
    <item>
      <title>9.3. auto-delete</title>
      <link>https://minorugh.github.io/.emacs.d/history/auto-delete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/auto-delete/</guid>
      <description>8.2. 空になったファイルを自動的に削除 howm や org でメモをとるときに、ゴミファイルが残らないように時々メンテしています。ファイルを開いて中味を確認してから、一度閉じて dited で削除するというプロセスは手間がかかりすぎます。
下記の設定をしておくと、C-x h で全選択して delete したあと kill-buffer することで自動的にファイルが削除されるので便利です。
(defun my:delete-file-if-no-contents () &amp;#34;Automatic deletion for empty files (Valid in all modes).&amp;#34; (when (and (buffer-file-name (current-buffer)) (= (point-min) (point-max))) (delete-file (buffer-file-name (current-buffer))))) (if (not (memq &amp;#39;my:delete-file-if-no-contents after-save-hook)) (setq after-save-hook (cons &amp;#39;my:delete-file-if-no-contents after-save-hook))) </description>
    </item>
    
    <item>
      <title>5.4. sprit-window-functions</title>
      <link>https://minorugh.github.io/.emacs.d/frame/sprit-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/sprit-window/</guid>
      <description>dimmer-mode との連携をさせるために、デフォルトのキーバインドをカスタマイズします。
 同じバッファーを分割したときは、follow-mode にする。 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *cus-sprit-window :bind ((&amp;#34;C-q&amp;#34; . other-window-or-split) (&amp;#34;C-x 2&amp;#34; . my:split-window-below) (&amp;#34;C-x 1&amp;#34; . my:delete-other-windows) (&amp;#34;C-x 0&amp;#34; . my:delete-window) (&amp;#34;&amp;lt;C-return&amp;gt;&amp;#34; . window-swap-states)) :init (defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (defun my:split-window-below () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (split-window-below) (follow-mode 1) (dimmer-mode 1)) (defun my:delete-window () &amp;#34;With turn off dimmer.&amp;#34; (interactive) (delete-window) (follow-mode -1) (dimmer-mode -1)) (defun my:delete-other-windows () &amp;#34;With turn off dimmer.</description>
    </item>
    
    <item>
      <title>7.4. display-number-mode</title>
      <link>https://minorugh.github.io/.emacs.d/display/display-number/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/display-number/</guid>
      <description>(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) ((lisp-interaction-mode-hook dired-mode-hook). my:disable-modes)) :bind (&amp;#34;&amp;lt;f9&amp;gt;&amp;#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () &amp;#34;Disable modes in scrtch buffer.&amp;#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0) (nyan-mode 0))) </description>
    </item>
    
    <item>
      <title>7.4. yatex</title>
      <link>https://minorugh.github.io/.emacs.d/editing/yatex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/yatex/</guid>
      <description>5.6. [yatex] YaTexで LaTex編集 yatex.el は、Emacsの上で動作する LaTeX の入力支援環境です。
ごく一般的な設定例ですが、参考になるとしたら dviprint-command-format に dvpd.sh というスクリプトを設定して、YateX.lpr コマンドでPDF作成 → プレビューまでの手順を一気に出来るように自動化している点でしょうか。
(leaf yatex :ensure t :mode (&amp;#34;\\.tex\\&amp;#39;&amp;#34; &amp;#34;\\.sty\\&amp;#39;&amp;#34; &amp;#34;\\.cls\\&amp;#39;&amp;#34;) :custom `((tex-command . &amp;#34;platex&amp;#34;) (dviprint-command-format . &amp;#34;dvpd.sh %s&amp;#34;) (YaTeX-kanji-code . nil) (YaTeX-latex-message-code . &amp;#39;utf-8) (YaTeX-default-pop-window-height . 15)) :config (leaf yatexprc :bind ((&amp;#34;M-c&amp;#34; . YaTeX-typeset-buffer) (&amp;#34;M-v&amp;#34; . YaTeX-lpr)))) YaTeX-lpr は、dviprint-command-format を呼び出すコマンドです。
dviファイルから dvipdfmx で PDF作成したあと、ビューアーを起動させて表示させるところまでをバッチファイルに書き、chmod +x dvpd.sh  として実行権限を付与してからPATHの通ったところに置きます。私は、/usr/loca/bin に置きました。
[dvpd.sh]
#!/bin/sh name=$1 dvipdfmx $1 &amp;amp;&amp;amp; evince ${name%.</description>
    </item>
    
    <item>
      <title>9.4. recentf</title>
      <link>https://minorugh.github.io/.emacs.d/history/recentf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/recentf/</guid>
      <description>;; recentf (leaf recentf :custom `((recentf-auto-cleanup . &amp;#39;never) (recentf-exclude . &amp;#39;(&amp;#34;\\.howm-keys&amp;#34; &amp;#34;Dropbox/backup&amp;#34; &amp;#34;.emacs.d/tmp/&amp;#34; &amp;#34;.emacs.d/elpa/&amp;#34; &amp;#34;/scp:&amp;#34;)))) </description>
    </item>
    
    <item>
      <title>5.5. tempbuf</title>
      <link>https://minorugh.github.io/.emacs.d/frame/tempbuf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/tempbuf/</guid>
      <description> tempbuf.el は不要になったと思われるバッファを自動的に kill してくれるパッケージ。 emacswiki.org/emacs/tempbuf.el: Automatically deleted in the background  使っていた時間が長い程、裏に回った時には長い時間保持してくれる。 つまり、一瞬開いただけのファイルは明示的に kill しなくても勝手にやってくれるのでファイルを開いてそのまま放置みたいなことをしがちなズボラな人間には便利なやつ。
 my:tembuf-ignore-files: 勝手に kill させないファイルの指定 find-file-hook: find-file や dired で開いたファイルが対象 dired buffer /magit-buffer: 強制的に削除  (leaf tempbuf :el-get minorugh/tempbuf :hook ((find-file-hook . my:find-file-tempbuf-hook) (dired-mode-hook . turn-on-tempbuf-mode) (magit-mode-hook . turn-on-tempbuf-mode) ) :init (setq my:tempbuf-ignore-files &amp;#39;(&amp;#34;~/Dropbox/org/task.org&amp;#34; &amp;#34;~/Dropbox/org/capture.org&amp;#34;)) (defun my:find-file-tempbuf-hook () (let ((ignore-file-names (mapcar &amp;#39;expand-file-name my:tempbuf-ignore-files))) (unless (member (buffer-file-name) ignore-file-names) (turn-on-tempbuf-mode))))) </description>
    </item>
    
    <item>
      <title>7.5. darkroom</title>
      <link>https://minorugh.github.io/.emacs.d/editing/darkroom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/darkroom/</guid>
      <description>[darkroom-mode] 執筆モード darkroom.el は、画面の余計な項目を最小限にして、文章の執筆に集中できるようにするパッケージです。
https://github.com/joaotavora/darkroom
[F12] キーで IN/OUT をトグルしています。 darkroom-mode から抜けるときは、revert-buffer で再読込してもとに戻します。
yes/no確認を聞かれるのが煩わしいので my:revery-buffer-no-confirm の関数を作りました。
(leaf darkroom :ensure t :bind ((&amp;#34;&amp;lt;f12&amp;gt;&amp;#34; . my:darkroom-in) (:darkroom-mode-map (&amp;#34;&amp;lt;f12&amp;gt;&amp;#34; . my:darkroom-out))) :config (defun my:darkroom-in () &amp;#34;Enter to the `darkroom-mode&amp;#39;.&amp;#34; (interactive) (view-mode 0) (diff-hl-mode 0) (display-line-numbers-mode 0) (darkroom-tentative-mode 1) (setq-local line-spacing 0.4)) (defun my:darkroom-out () &amp;#34;Returns from `darkroom-mode&amp;#39;to the previous state.&amp;#34; (interactive) (my:linespacing) (darkroom-tentative-mode 0) (display-line-numbers-mode 1) (my:revert-buffer-no-confirm)) (defun my:revert-buffer-no-confirm () &amp;#34;Revert buffer without confirmation.&amp;#34; (interactive) (revert-buffer t t))) </description>
    </item>
    
    <item>
      <title>9.5. savehist</title>
      <link>https://minorugh.github.io/.emacs.d/history/savehist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/savehist/</guid>
      <description>;; Don&amp;#39;t clear kill-ring when restart emacs (savehist-additional-variables . &amp;#39;(kill-ring)) </description>
    </item>
    
    <item>
      <title>5.6. winner-mode</title>
      <link>https://minorugh.github.io/.emacs.d/frame/winner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/winner/</guid>
      <description>11.3. [Winner.el] ウインドウ構成の履歴を辿る  ビルトインの winner.el を使います．  ウィンドウ分割状況と各ウィンドウで表示していたバッファの履歴を辿ることができます。 winner-undo で直前の状態に戻せます。例えば、誤って C-x 0 で分割ウィンドウを閉じた時でも即座に元の状態に戻すことが可能です。</description>
    </item>
    
    <item>
      <title>7.6. ivy / counsel</title>
      <link>https://minorugh.github.io/.emacs.d/editing/ivy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/ivy/</guid>
      <description>ivy は、helm と双璧を成す Emacsの補完システムです。
リスト表示された多くの選択肢から、自分が使いたいものを高速に絞り込んで効率良く選び出す。 このシンプルかつ極めて重要なタスクを ivy が手助けしてくれます．
(leaf counsel :ensure t :defer-config (ivy-mode) :bind ((&amp;#34;C-r&amp;#34; . swiper-thing-at-point) (&amp;#34;C-s&amp;#34; . swiper-region) (&amp;#34;C-:&amp;#34; . counsel-switch-buffer) (&amp;#34;s-a&amp;#34; . counsel-ag) (&amp;#34;s-r&amp;#34; . counsel-rg) (&amp;#34;s-f&amp;#34; . counsel-fontawesome) (&amp;#34;M-x&amp;#34; . counsel-M-x) (&amp;#34;M-y&amp;#34; . counsel-yank-pop) (&amp;#34;C-x m&amp;#34; . counsel-mark-ring) (&amp;#34;C-x C-b&amp;#34; . ibuffer) (&amp;#34;C-x C-f&amp;#34; . counsel-find-file) (&amp;#34;C-x C-r&amp;#34; . counsel-recentf)) :custom `((search-default-mode . nil) (ivy-use-virtual-buffers . t) (ivy-use-selectable-prompt . t) (enable-recursive-minibuffers . t) (counsel-find-file-ignore-regexp . (regexp-opt completion-ignored-extensions)) (ivy-format-functions-alist .</description>
    </item>
    
    <item>
      <title>9.6. hist-files</title>
      <link>https://minorugh.github.io/.emacs.d/history/hist-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/hist-files/</guid>
      <description>;; change-default-file-location (leaf change-default-file-location :custom `((recentf-save-file . &amp;#34;~/.emacs.d/tmp/recentf&amp;#34;) (save-place-file . &amp;#34;~/.emacs.d/tmp/places&amp;#34;) (savehist-file . &amp;#34;~/.emacs.d/tmp/history&amp;#34;) (url-configuration-directory . &amp;#34;~/.emacs.d/tmp/url&amp;#34;) (bookmark-file . &amp;#34;~/.emacs.d/tmp/bookmarks&amp;#34;))) </description>
    </item>
    
    <item>
      <title>5.7. doom-thmes</title>
      <link>https://minorugh.github.io/.emacs.d/frame/doom-themes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/doom-themes/</guid>
      <description>(leaf doom-themes :ensure t :hook (after-init-hook . (lambda () (load-theme &amp;#39;doom-dracula t))) :custom (doom-themes-enable-italic . nil) (doom-themes-enable-bold . nil) :config (doom-themes-neotree-config) (doom-themes-org-config)) </description>
    </item>
    
    <item>
      <title>7.7. yasunippets / company</title>
      <link>https://minorugh.github.io/.emacs.d/editing/company/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/company/</guid>
      <description>(leaf yasnippet :ensure t :hook (after-init-hook . yas-global-mode) :config (leaf yasnippet-snippets :ensure t)) (leaf company :ensure t :hook (after-init-hook . global-company-mode) :bind ((&amp;#34;C-&amp;lt;return&amp;gt;&amp;#34; . company-complete) (&amp;#34;C-&amp;lt;tab&amp;gt;&amp;#34; . company-yasnippet) (:company-active-map (&amp;#34;&amp;lt;tab&amp;gt;&amp;#34; . company-complete-common-or-cycle) (&amp;#34;&amp;lt;backtab&amp;gt;&amp;#34; . company-select-previous) (&amp;#34;&amp;lt;muhenkan&amp;gt;&amp;#34; . company-abort))) :custom `((company-transformers . &amp;#39;(company-sort-by-backend-importance)) (company-idle-delay . 0) (company-require-match . &amp;#39;never) (company-minimum-prefix-length . 2) (company-selection-wrap-around . t) (completion-ignore-case . t) (company-dabbrev-downcase . nil)) :config (defvar company-mode/enable-yas t &amp;#34;Enable yasnippet for all backends.&amp;#34;) (defun company-mode/backend-with-yas (backend) (if (or (not company-mode/enable-yas) (and (listp backend) (member &amp;#39;company-yasnippet backend))) backend (append (if (consp backend) backend (list backend)) &amp;#39;(:with company-yasnippet)))) (setq company-backends (mapcar #&amp;#39;company-mode/backend-with-yas company-backends))) </description>
    </item>
    
    <item>
      <title>9.7. dired</title>
      <link>https://minorugh.github.io/.emacs.d/history/dired/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/dired/</guid>
      <description>(leaf dired :hook ((dired-mode-hook . dired-my-append-buffer-name-hint) (dired-mode-hook . (lambda () (load &amp;#34;dired-x&amp;#34;) (dired-omit-mode 1)))) :bind (:dired-mode-map (&amp;#34;&amp;lt;left&amp;gt;&amp;#34; . dired-up-alternate-directory) (&amp;#34;&amp;lt;right&amp;gt;&amp;#34; . dired-open-in-accordance-with-situation) (&amp;#34;RET&amp;#34; . dired-open-in-accordance-with-situation) (&amp;#34;&amp;lt;&amp;#34; . beginning-of-buffer) (&amp;#34;&amp;gt;&amp;#34; . end-of-buffer) (&amp;#34;SPC&amp;#34; . my:dired-toggle-mark) (&amp;#34;C-g&amp;#34; . my:dired-unmark-all) (&amp;#34;f&amp;#34; . counsel-find-file) (&amp;#34;r&amp;#34; . wdired-change-to-wdired-mode) (&amp;#34;o&amp;#34; . dired-open-file) (&amp;#34;[&amp;#34; . dired-hide-details-mode) (&amp;#34;a&amp;#34; . toggle-dired-listing-switches) (&amp;#34;q&amp;#34; . dired-dwim-quit-window) (&amp;#34;i&amp;#34; . call-sxiv) (&amp;#34;s&amp;#34; . sudo-edit) (&amp;#34;e&amp;#34; . gedit-open-dired) (&amp;#34;@&amp;#34; . dired-do-gist) (&amp;#34;.&amp;#34; . dired-omit-mode)) :custom `((dired-dwim-target .</description>
    </item>
    
    <item>
      <title>5.8. doom-modeline</title>
      <link>https://minorugh.github.io/.emacs.d/frame/doom-modeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/frame/doom-modeline/</guid>
      <description>(leaf doom-modeline :ensure t :hook (after-init-hook . doom-modeline-mode) :custom (doom-modeline-icon . t) (doom-modeline-major-mode-icon . nil) (doom-modeline-minor-modes . nil) :config (line-number-mode 0) (column-number-mode 0) (doom-modeline-def-modeline &amp;#39;main &amp;#39;(bar window-number matches buffer-info remote-host buffer-position parrot selection-info) &amp;#39;(misc-info persp-name lsp github debug minor-modes input-method major-mode process vcs checker)) :init (leaf nyan-mode :ensure t :config (nyan-mode 1) (nyan-start-animation))) </description>
    </item>
    
    <item>
      <title>7.8. key-chord</title>
      <link>https://minorugh.github.io/.emacs.d/editing/key-chord/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/key-chord/</guid>
      <description>[key-chord.el] 同時押しでキーバインド  同時押しというキーバインドを提供してくれるやつ 同時押し時の許容時間、その前後で別のキーが押されていたら発動しない判断をする、みたいな設定を入れている。  (leaf key-chord :ensure t :hook (after-init-hook . key-chord-mode) :chord ((&amp;#34;df&amp;#34; . counsel-descbinds) (&amp;#34;l;&amp;#34; . init-loader-show-log) (&amp;#34;@@&amp;#34; . howm-list-all) (&amp;#34;jk&amp;#34; . open-junk-file)) :custom `((key-chord-two-keys-delay . 0.25) (key-chord-safety-interval-backward . 0.1) (key-chord-safety-interval-forward . 0.15))) キーの同時押し判定は 0.15 秒で、それらのキーが押される直前の 0.1 秒以内、または直後の 0.15 秒に押されていたら発動しない、という設定にしている。
改良版の作者の記事だと、直後判定は 0.25 秒で設定されていたが自分は Hydra の起動にも使っている上に、よく使うやつは覚えているので表示を待たずに次のキーを押すので 0.25 秒も待っていられないという事情があった。</description>
    </item>
    
    <item>
      <title>9.8. neotree</title>
      <link>https://minorugh.github.io/.emacs.d/history/neotree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/history/neotree/</guid>
      <description>(leaf neotree :ensure t :bind ((&amp;#34;&amp;lt;f10&amp;gt;&amp;#34; . neotree-find) (:neotree-mode-map (&amp;#34;RET&amp;#34; . neotree-enter-hide) (&amp;#34;a&amp;#34; . neotree-hidden-file-toggle) (&amp;#34;&amp;lt;left&amp;gt;&amp;#34; . neotree-select-up-node) (&amp;#34;&amp;lt;right&amp;gt;&amp;#34; . neotree-change-root) (&amp;#34;&amp;lt;f10&amp;gt;&amp;#34; . neotree-toggle))) :custom `((neo-keymap-style . &amp;#39;concise) (neo-create-file-auto-open . t))) (with-eval-after-load neotree ;; Change neotree&amp;#39;s font size ;; Tips from https://github.com/jaypei/emacs-neotree/issues/218 (defun neotree-text-scale () &amp;#34;Neotree text scale.&amp;#34; (interactive) (text-scale-adjust 0) (text-scale-decrease 0.8) (message nil)) (add-hook &amp;#39;neo-after-create-hook (lambda (_) (call-interactively &amp;#39;neotree-text-scale))) ;; neotree enter hide ;; Tips from https://github.com/jaypei/emacs-neotree/issues/77 (defun neo-open-file-hide (full-path &amp;amp;optional arg) &amp;#34;Neotree enter hide with FULL-PATH ARG.</description>
    </item>
    
    <item>
      <title>7.9. smartparens</title>
      <link>https://minorugh.github.io/.emacs.d/editing/smartparens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/smartparens/</guid>
      <description>対応する括弧の挿入をアシスト smartparens.el の設定がいまいちよくわからず、とりあえず次のように設定して今のところ機嫌よく働いている。
(leaf smartparens :ensure t :require smartparens-config :hook (prog-mode-hook . turn-on-smartparens-mode) :config (smartparens-global-mode t)) </description>
    </item>
    
    <item>
      <title>7.10. iedit</title>
      <link>https://minorugh.github.io/.emacs.d/editing/iedit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/iedit/</guid>
      <description>[iedit] 選択領域を別の文字列に置き換える  idet.el は、バッファー内の複数箇所を同時に編集するツールです。  同じような機能のものは、複数あるようですが、わたしはこれを愛用しています。
 multi-cursors.el replace-from-region.el anzu.el  MELPAからpackage-installするだけで使えます。
対象範囲を選択して C-; を押すとiedit-modeとなり、選択したキーワードが全てハイライト表示され、モードラインに押すとIedit:とキーワードの出現した回数が表示され、ミニバッファにもメッセージが表示されます。
ここで、ハイライトされた部分を編集すると、他のハイライトも同時に編集されるようになります。編集後、もう一度 C-; を押すと確定されiedet-modeを抜けます。
かなりの頻度で使うので、Emacsでは使うことのない &amp;lt;insert&amp;gt; にキーバインドしています。</description>
    </item>
    
    <item>
      <title>7.11. migemo</title>
      <link>https://minorugh.github.io/.emacs.d/editing/migemo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/migemo/</guid>
      <description>[migemo] ローマ字のまま日本語をインクリメンタル検索可能にする。 migemo は元々 Ruby で書かれていたようですが，最近の Ruby では動かないので C 言語で再実装された cmigemo を使うのが一般的のよう。 aptでインストール。
$ sudo apt install cmigemo インストール完了したら、下記コマンドで実行できる事を確認しておきます。
$ cmigemo --help Emacsの設定は下記のとおりです。
(leaf migemo :ensure t :hook (after-init-hook . migemo-init) :when (executable-find &amp;#34;cmigemo&amp;#34;) :custom `((migemo-command . &amp;#34;cmigemo&amp;#34;) (migemo-dictionary . &amp;#34;/usr/share/cmigemo/utf-8/migemo-dict&amp;#34;))) [swiper-migemo] swiperでもmigemoを使う avy-migemo-e.g.swiper.el を使って出来ていたのですが、２年ほど前から更新が止まってしまっていて動きません。
つい最近、avy-migemo を使わない swiper-migemoを GitHubで見つけたので試した処、機嫌よく動いてくれています。 MELPAにはアップされていないみたいなので el-get で取得しています。
(leaf swiper-migemo :doc &amp;#34;https://github.com/tam17aki/swiper-migemo&amp;#34; :el-get tam17aki/swiper-migemo :config (global-swiper-migemo-mode +1)) </description>
    </item>
    
    <item>
      <title>7.12. selected</title>
      <link>https://minorugh.github.io/.emacs.d/editing/selected/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/selected/</guid>
      <description>[selected] リージョン選択時のアクションを制御 selected.el は、選択領域に対するスピードコマンドです。
Emacsバッファーで領域を選択した後、バインドしたワンキーを入力するとコマンドが実行されます。 コマンドの数が増えてきたら、ヘルプ代わりに使える counsel-selected も便利そうです。
(leaf selected :ensure t :hook (after-init-hook . selected-global-mode) :bind (:selected-keymap (&amp;#34;;&amp;#34; . comment-dwim) (&amp;#34;c&amp;#34; . clipboard-kill-ring-save) (&amp;#34;s&amp;#34; . swiper-thing-at-point) (&amp;#34;t&amp;#34; . google-translate-auto) (&amp;#34;T&amp;#34; . chromium-translate) (&amp;#34;W&amp;#34; . my:weblio) (&amp;#34;k&amp;#34; . my:koujien) (&amp;#34;e&amp;#34; . my:eijiro) (&amp;#34;g&amp;#34; . my:google))) browse-urlで検索サイトで開く 検索結果を browse-url で表示させるユーザーコマンドは、検索 urlのフォーマットとさえわかれば、パッケージツールに頼らずともお好みのマイコマンドを作成できます。
(defun my:koujien (str) (interactive (list (my:get-region nil))) (browse-url (format &amp;#34;https://sakura-paris.org/dict/広辞苑/prefix/%s&amp;#34; (upcase (url-hexify-string str))))) (defun my:weblio (str) (interactive (list (my:get-region nil))) (browse-url (format &amp;#34;https://www.</description>
    </item>
    
    <item>
      <title>7.13. pangu-spacing</title>
      <link>https://minorugh.github.io/.emacs.d/editing/pangu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/pangu/</guid>
      <description>;; Add space between full-width and half-width (leaf pangu-spacing :ensure t :after mozc :hook ((markdown-mode-hook text-mode-hook) . pangu-spacing-mode) :config (setq pangu-spacing-include-regexp (rx (or (and (or (group-n 3 (any &amp;#34;。，！？；：「」（）、&amp;#34;)) (group-n 1 (or (category japanese)))))) (group-n 2 (in &amp;#34;a-zA-Z&amp;#34;))))) </description>
    </item>
    
    <item>
      <title>7.14. fontawesome</title>
      <link>https://minorugh.github.io/.emacs.d/editing/fontawesome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/editing/fontawesome/</guid>
      <description>Font-awesome の入力をcounsel で支援してくれる。
(leaf fontawesome :ensure t :bind (&amp;#34;s-f&amp;#34; . counsel-fontwesame)) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://minorugh.github.io/.emacs.d/hydra/hydra-make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/hydra/hydra-make/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://minorugh.github.io/.emacs.d/hydra/hydra-markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/hydra/hydra-markdown/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://minorugh.github.io/.emacs.d/hydra/hydra-quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/hydra/hydra-quick/</guid>
      <description>7.1. [hydra-menu] 作業選択メニュー hydra-work-menu には、 ブログ記事のほかWEB日記や俳句関係のシリーズ記事の追加、編集など、毎日頻繁に開くワークスペースへのショートカットを設定しています。
hydra-quick-menu の方には、 編集作業で頻繁に使うツール群のほか、my:dired でプロジェクトのディレクトリを一発で開くためのショートカットなどを設定しています。
この２つの hydra は、いわば私の秘書のような役割で、どちらからでも相互にトグルで呼び出せるようにしています。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://minorugh.github.io/.emacs.d/hydra/hydra-work/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/hydra/hydra-work/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1.1. eary-init.el</title>
      <link>https://minorugh.github.io/.emacs.d/startup/eary-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/eary-init/</guid>
      <description>[eary-init.el] 早期初期化ファイル  early-init.el は、Emacs27から導入されました。 minorugh/.emacs.d/early-init.el  init.el でパッケージシステムやGUIの初期化が実行される前にロードされるので、UI関係や package-enable-at-startup のようなパッケージ初期化プロセスに影響を与える変数をカスタマイズできます。
GCを減らす GC の閾値を最大にしておくことで GC を実質止めることができます。とりあえず書いておけば速くなる系なのでおすすめです。
;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) eary-init.el の先頭に書くことが重要です。
Package の初期化を抑制する Emacs27では、(package-initialize) が 2回実行されます。 (1回は init ファイルの評価中に、もう 1回は Emacs が initファイルの読み取りを終了した後に)。
1回目を抑制するために以下を eary-init.el に記述することで初期化が少し早くなります。
;; For slightly faster startup (setq package-enable-at-startup nil) 常に最新のバイトコードをロードする ;; Always load newest byte code (setq load-prefer-newer t) フレームのサイズ変更を禁止する ;; Inhibit resizing frame (setq frame-inhibit-implied-resize t) これらを無効にする方が速い (初期化される前) ;; Faster to disable these here (before they&amp;#39;ve been initialized) (push &amp;#39;(fullscreen .</description>
    </item>
    
    <item>
      <title>1.2. speed up startup</title>
      <link>https://minorugh.github.io/.emacs.d/startup/speed-up/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/speed-up/</guid>
      <description>Magic File Name を一時的に無効にすることで、起動時間を短縮できます。 GC設定とともに設定ファイル読み込み後に正常値に戻します。  ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover file name handlers.&amp;#34; (setq file-name-handler-alist (delete-dups (append file-name-handler-alist old-file-name-handler-alist))))))) ;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover GC values after startup.&amp;#34; (setq gc-cons-threshold 800000))) ※ init.el の先頭に書きます。</description>
    </item>
    
    <item>
      <title>1.3. leaf.el</title>
      <link>https://minorugh.github.io/.emacs.d/startup/leaf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/leaf/</guid>
      <description>Emacsの設定管理は、これまで use-pacage.el を使っていましたが、 @conao3 さんの開発された leaf.el に触発されて全面的に書き直しました。
 Emacs入門から始めるleaf.el入門  leaf.el に対応したinit.el Packageは、基本MELPAからインストールしていますが、el-getも使えるようにしています。 自作パッケージもGitHubリポジトリで管理してel-getでインストールすることでシンプルなパッケージ管理が出来ます。
;;; init.el --- Emacs first Configuration. -*- lexical-binding: t -*- ;;; Commentary: ;; ;; Compatible with Emacs 27 and later ;; Aiming for a fancy and fast Emacs configuration ;; ;;; Code: ;; (setq debug-on-error t) ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover file name handlers.</description>
    </item>
    
    <item>
      <title>1.4. init-loader.el</title>
      <link>https://minorugh.github.io/.emacs.d/startup/init-loader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/init-loader/</guid>
      <description>[init-loader.el] 設定ファイル群のローダー  emacs-jp/init-loader: Loader of configuration files.  指定されたディレクトリから構成ファイルをロードします。これにより、構成を分類して複数のファイルに分けることができます。
init-loader には、エラーが出た設定ファイルは読み込まれない&amp;hellip;という特徴があり原因究明がしやすくなるというメリットがある。またログの出力機能を備えていることもメリットとして挙げられる。
起動時間が犠牲になるということで敬遠される向きもあるが微々たるもので、恩恵のほうが遥かに大きい。
(leaf init-loader :ensure t :config (custom-set-variables &amp;#39;(init-loader-show-log-after-init &amp;#39;error-only)) (init-loader-load)) デフォルトで ~/.emacs.d/inits デレクトリ以下のファイルを読み込みますが、変更したいときは下記のように指定すればいいようです。 自分は、デフォルトで使っています。
;; Load configuration files in &amp;#39;/path/to/init-directory&amp;#39;. (init-loader-load &amp;#34;/path/to/init-directory&amp;#34;) </description>
    </item>
    
    <item>
      <title>1.5. test.el</title>
      <link>https://minorugh.github.io/.emacs.d/startup/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/test/</guid>
      <description>[test.el] 最小限の emacs を起動させるための設定 test.el は、 新しいパッケージを試したり設定をテストしたり、エラー等で Emacsが起動しない場合などに使用します。
以下を .zshrc または .bashrc に記述し反映させたのち、シェルから eq と入力することで起動することがでます。
alias eq = &amp;#39;emacs -q -l ~/.emacs.d/test.el&amp;#39; ファイルの PATH は、ご自分の環境に応じて修正が必要です。</description>
    </item>
    
    <item>
      <title>1.6. dashboard</title>
      <link>https://minorugh.github.io/.emacs.d/startup/dashboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/dashboard/</guid>
      <description>[dashboard.el]起動初期画面をイケメンにする 100分の1秒でもemacsの起動を早くしようと試行錯誤している一方、せめて初期画面くらいは、ホットするようなものにしたい…ということで、dashbord.el を導入してみた。
emacs-dashboard: An extensible emacs startup screen
 どのような状況からでも dashboard画面に戻れるように設定しています。 &amp;lt;home&amp;gt; キーのトグル操作で編集中のバッファーとdashboard画面とを行き来します。  (leaf dashboard :ensure t :hook ((after-init-hook . dashboard-setup-startup-hook) (dashboard-mode-hook . page-break-lines-mode)) :defun (dashboard-setup-startup-hook) :bind ((&amp;#34;&amp;lt;home&amp;gt;&amp;#34; . open-dashboard) (:dashboard-mode-map (&amp;#34;c&amp;#34; . chromium-calendar) (&amp;#34;y&amp;#34; . chromium-yahoo-japan) (&amp;#34;n&amp;#34; . chromium-nhk-news) (&amp;#34;w&amp;#34; . chromium-weather) (&amp;#34;t&amp;#34; . chromium-tweetdeck) (&amp;#34;h&amp;#34; . chromium-homepage) (&amp;#34;m&amp;#34; . sylpheed) (&amp;#34;s&amp;#34; . slack) (&amp;#34;.&amp;#34; . hydra-browse/body) (&amp;#34;&amp;lt;home&amp;gt;&amp;#34; . quit-dashboard))) :advice (:override emacs-init-time ad:emacs-init-time) :init (leaf page-break-lines :ensure t) :config ;; Set the title (setq dashboard-banner-logo-title (concat &amp;#34;GNU Emacs &amp;#34; emacs-version &amp;#34; kernel &amp;#34; (car (split-string (shell-command-to-string &amp;#34;uname -r&amp;#34;))) &amp;#34; Debian &amp;#34; (car (split-string (shell-command-to-string &amp;#34;cat /etc/debian_version&amp;#34;))) &amp;#34; 86_64 GNU/Linux&amp;#34;)) ;; Set the banner (setq dashboard-startup-banner (expand-file-name &amp;#34;emacs.</description>
    </item>
    
    <item>
      <title>2.1. language / coding</title>
      <link>https://minorugh.github.io/.emacs.d/core/encode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/encode/</guid>
      <description>シンプルにこれだけです。
(set-language-environment &amp;#34;Japanese&amp;#34;) (prefer-coding-system &amp;#39;utf-8) </description>
    </item>
    
    <item>
      <title>2.3. emacs-mozc</title>
      <link>https://minorugh.github.io/.emacs.d/core/mozc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/mozc/</guid>
      <description>[emacs-mozc] 日本語入力システム（インプットメソッド）  Debian11 にインストールした Emacs上で emacs-mozc を使っています。 debian でのインストール手順は以下の通り。  $ sudo apt-get install fcitx-mozc emacs-mozc Emacsをソースからビルドするときに --without-xim しなかったので、インライン XIMでも日本語入力ができてしまいます。 特に使い分けする必要もなく紛らわしいので .Xresources で XIM無効化の設定をしました。
! ~/.Xresources ! Emacs XIMを無効化 Emacs*useXIM: false 句読点などを入力したとき、わざわざ mozcに変換してもらう必要はないので以下を設定しておくことでワンアクションスピーディーになります。
(leaf mozc :ensure t :bind ((&amp;#34;&amp;lt;hiragana-katakana&amp;gt;&amp;#34; . toggle-input-method) (:mozc-mode-map (&amp;#34;,&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;、&amp;#34;))) (&amp;#34;.&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;。&amp;#34;))) (&amp;#34;?&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;？&amp;#34;))) (&amp;#34;!&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;！&amp;#34;))))) :custom `((default-input-method .</description>
    </item>
    
    <item>
      <title>2.4. server / emacsclient</title>
      <link>https://minorugh.github.io/.emacs.d/core/server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/server/</guid>
      <description> shell-command で emacsclient をよく使うので、Emacs起動時に server を起動させています。 重複起動させない設定です。  ;; Server start for emacs-client (leaf server :require t :config (unless (server-running-p) (server-start))) </description>
    </item>
    
    <item>
      <title>2.5. exec-path-from-shell</title>
      <link>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</guid>
      <description>[exec-path-from-shell.el] 設定をシェルから継承する  exec-path-from-shell は、シェルに設定した PATH の情報を継承して exec-path や PATH を設定してくれます。 自分は、shell-commad や compile-command をよく使うので必須のパッケージです。  purcell/exec-path-from-shell: Make Emacs use the $PATH set up by the user&amp;rsquo;s shell
(leaf exec-path-from-shell :ensure t :when (memq window-system &amp;#39;(mac ns x)) :hook (after-init-hook . exec-path-from-shell-initialize) :custom (exec-path-from-shell-check-startup-files . nil)) </description>
    </item>
    
    <item>
      <title>2.6. uniguify</title>
      <link>https://minorugh.github.io/.emacs.d/core/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/uniquify/</guid>
      <description>ビルトインの uniquify は、同じバッファ名が開かれた場合に区別する設定です。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>2.7. change gloal keybind</title>
      <link>https://minorugh.github.io/.emacs.d/core/change-keybind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/change-keybind/</guid>
      <description>グローバルキーバインドを自分好みにカスタマイズしました。 前準備として以下を設定しておきます。
 クリップボードを使えるようにする  ;; Use the X11 clipboard (setq select-enable-clipboard t)  マウスで選択した領域を自動コピー マウスで選択すると，勝手にペーストボードにデータが流れます．  (setq mouse-drag-copy-region t) グローバルキーバインドをカスタマイズする  C-w は、kill-ring-save に割り当てられたものですが、region 選択されていないときは、一行削除になるようにカスタマイズしてます。 C-x k の kill-buffer は、yes/no 確認されるのが煩わしいので、確認なしの kill-this-buffer を愛用しています。  ;; Change global key bind (leaf cus-global-keybind :bind ((&amp;#34;M-w&amp;#34; . clipboard-kill-ring-save) (&amp;#34;C-w&amp;#34; . my:kill-whole-line-or-region) (&amp;#34;s-c&amp;#34; . clipboard-kill-ring-save) (&amp;#34;s-v&amp;#34; . clipboard-yank) (&amp;#34;M-/&amp;#34; . kill-this-buffer))) ;; Overwrite `C-w&amp;#39; to the whole-line-or-region (defun my:kill-whole-line-or-region () &amp;#34;If the region is active, to kill region.</description>
    </item>
    
    <item>
      <title>3.1. sequential-command</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/sequential-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/sequential-command/</guid>
      <description>[sequential-command.el] バッファーの先頭と最終行への移動を簡単に sequential-command は、標準の C-a C-e を拡張し、バッファーの先頭と最終行への移動を簡単にしてくれます。
 https://github.com/HKey/sequential-command C-a を連続で打つことで行頭→ファイルの先頭→元の位置とカーソルが移動 C-e を連続で打つことで行末→ファイルの最終行→元の位置とカーソルが移動  地味ながら一度使うと便利すぎて止められません。
MELPAからインストールできますが、私は HKey氏の改良版を el-get でインストールしました。
(leaf sequential-command :doc &amp;#34;https://bre.is/6Xu4fQs6&amp;#34; :el-get HKey/sequential-command :config (leaf sequential-command-config :hook (emacs-startup-hook . sequential-command-setup-keys))) </description>
    </item>
    
    <item>
      <title>3.2. other-window-or-split</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/other-window-or-sprit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/other-window-or-sprit/</guid>
      <description> other-window-or-split は、画面分割コマンド C-x 3 を拡張します。 画面分割されていないときは、左右分割して follow-mode dimmer-mode も ON にしています。（詳細後述） 画面移動だけなら C-c o でもいいですが，ワンアクションで分割と移動を賢くしてくれるので便利です。  (defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (bind-key &amp;#34;C-q&amp;#34; &amp;#39;other-window-or-split) </description>
    </item>
    
    <item>
      <title>3.3. my:jump-brace</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/jump-brace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/jump-brace/</guid>
      <description>my:jump-brace は、括弧の先頭と最後へ交互にポイント移動します。
(defun my:jump-brace () &amp;#34;Jump to the corresponding parenthesis.&amp;#34; (interactive) (let ((c (following-char)) (p (preceding-char))) (if (eq (char-syntax c) 40) (forward-list) (if (eq (char-syntax p) 41) (backward-list) (backward-up-list))))) (bind-key &amp;#34;C-M-9&amp;#34; &amp;#39;my:jump-brace) 標準機能  C-M-SPC (mark-sexp) は，カーソル位置から順方向に選択． C-M-U (backward-up-list) は，一つ外のカッコの先頭にポイントを移す．  でも、上記標準機能はなにげに使いにくいです。</description>
    </item>
    
    <item>
      <title>3.4. my:exchange-point-and-mark</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/mark-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/mark-command/</guid>
      <description> my:exchange-point-and-mark は、直前の編集ポイントと現在のポイントとを行き来できる設定です。  (defun my:exchange-point-and-mark () &amp;#34;No mark active `exchange-point-and-mark&amp;#39;.&amp;#34; (interactive) (exchange-point-and-mark) (deactivate-mark))	(bind-key &amp;#34;C-x C-x&amp;#34; &amp;#39;my:exchange-point-and-mark) 標準機能の C-u C-SPC でもマーク箇所を辿れます。 (setq set-mark-command-repeat-pop t) (setq mark-ring-max 32) (setq global-mark-ring-max 64) </description>
    </item>
    
    <item>
      <title>3.5. expand-region</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/expand-region/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/expand-region/</guid>
      <description>[expand-refion.el] カーソル位置を起点に選択範囲を賢く広げてくれる expand-region.el は、カーソル位置を起点として前後に選択範囲を広げてくれます。
2回以上呼ぶとその回数だけ賢く選択範囲が広がりますが、2回目以降は設定したキーバインドの最後の一文字を連打すれば OKです。その場合、選択範囲を狭める時は - を押し， 0 を押せばリセットされます。
(leaf expand-region :ensure t :bind (&amp;#34;C-@&amp;#34; . er/expand-region)) </description>
    </item>
    
    <item>
      <title>4.1. font setting</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/font/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/font/</guid>
      <description>GUI / CUI 共通で Cica を使っています。  Cicaフォントは、Hack、DejaVu Sans Mono、Rounded Mgen+、Noto Emoji等のフォントを組み合わせて調整をした、日本語の等幅フォントです。
 プログラミング用日本語等幅フォント Cica Think Pad を2台使っていますので、環境を取得して設定を変えています。  フォントの設定  メイン機（Thinkpad E590）とサブ機（Thinkpad X250）とでそれぞれに適した値を決めています。  (add-to-list &amp;#39;default-frame-alist &amp;#39;(font . &amp;#34;Cica-18&amp;#34;)) ;; for sub-machine (when (string-match &amp;#34;x250&amp;#34; (code-command-to-string &amp;#34;uname -n&amp;#34;)) (add-to-list &amp;#39;default-frame-alist &amp;#39;(font . &amp;#34;Cica-15&amp;#34;))) Cicaフォントのインストール   Linux 環境でのインストールの方法です。
  オフィシャルページにある最新の Cica v5.03 は、 page-break-lines で表示が乱れます。
   Cica-v5.0.1のダウンロードページから、 (Cica-v5.0.1.zip) をダウンロードします。 上記サイトの存続は怪しいので自分のサイトにも置いておきます。 Cica-v5.0.1.zip  zipファイルを展開します。  $ unzip Cica-v5.</description>
    </item>
    
    <item>
      <title>4.2. hl-line-mode</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/hl-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/hl-line/</guid>
      <description>ビルトインの hl-line-mode は、カーソル行に色をつける設定です。
 http://murakan.cocolog-nifty.com/blog/2009/01/emacs-tips-1d45.html https://www.emacswiki.org/emacs/highlight-current-line.el  機能別にhl-line のON/OFF や色を変えたりという設定もできますが、 私の場合は、シンプルに global 設定して色は theme に依存というスタイルです。
(global-hl-line-mode 1) </description>
    </item>
    
    <item>
      <title>4.3. blink-cursor-mode</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/blink-cursor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/blink-cursor/</guid>
      <description> blink-cursor-mode を設定してカーソルの点滅を制御します。  以下の例では、入力が止まってから 10 秒後に 0.3 秒間隔で点滅します。次に入力が始まるまで点滅が続きます．
(setq blink-cursor-blinks 0) (setq blink-cursor-interval 0.3) (setq blink-cursor-delay 10) (add-hook &amp;#39;emacs-startup-hook . blink-cursor-mode) </description>
    </item>
    
    <item>
      <title>4.4. ivy-format-function-arrow</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/ivy-format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/ivy-format/</guid>
      <description> ivy-mode の選択行をアイコンで強調する設定です。  (defun my:ivy-format-function-arrow (cands) &amp;#34;Transform into a string for minibuffer with CANDS.&amp;#34; (ivy--format-function-generic (lambda (str) (concat (if (display-graphic-p) (all-the-icons-octicon &amp;#34;chevron-right&amp;#34; :height 0.8 :v-adjust -0.05) &amp;#34;&amp;gt;&amp;#34;) (propertize &amp;#34; &amp;#34; &amp;#39;display `(space :align-to 2)) (ivy--add-face str &amp;#39;ivy-current-match))) (lambda (str) (concat (propertize &amp;#34; &amp;#34; &amp;#39;display `(space :align-to 2)) str)) cands &amp;#34;\n&amp;#34;)) (setq ivy-format-functions-alist &amp;#39;((t . my:ivy-format-function-arrow))) </description>
    </item>
    
    <item>
      <title>4.5. pare</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/paren/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/paren/</guid>
      <description>(leaf paren :hook (after-init-hook . show-paren-mode) :custom `((show-paren-style . &amp;#39;parenthesis) (show-paren-when-point-inside-paren . t) (show-paren-when-point-in-periphery . t))) </description>
    </item>
    
    <item>
      <title>4.6. rainbow-delimiters</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/rainbow-delimiters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/rainbow-delimiters/</guid>
      <description>(leaf rainbow-delimiters :ensure t :hook (prog-mode-hook . rainbow-delimiters-mode)) </description>
    </item>
    
    <item>
      <title>4.7. rainbow-mode</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/rainbow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/rainbow/</guid>
      <description> rainbow-mode.el は red, green などの色名や #aabbcc といったカラーコードから実際の色を表示するマイナーモードです。 常時表示しているとうざいときもあるので、global 設定しないで必要なときだけ使えるようにしています。  (leaf rainbow-mode :ensure t :bind (&amp;#34;C-c r&amp;#34; . rainbow-mode)) </description>
    </item>
    
    <item>
      <title>4.8. volatile-highlight</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/volatile-highlights/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/volatile-highlights/</guid>
      <description> volatile-highlights.el は、コピペした領域を強調します。 下記の設定は、コピペ直後の数秒に限定してコピペした領域をフラッシングさせます。  (leaf volatile-highlights :ensure t :hook (after-init-hook . volatile-highlights-mode) :config (when (fboundp &amp;#39;pulse-momentary-highlight-region) (defun my:vhl-pulse (beg end &amp;amp;optional _buf face) &amp;#34;Pulse the changes.&amp;#34; (pulse-momentary-highlight-region beg end face)) (advice-add #&amp;#39;vhl/.make-hl :override #&amp;#39;my:vhl-pulse))) </description>
    </item>
    
    <item>
      <title>4.9. whitespace</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/whitespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/whitespace/</guid>
      <description>(leaf whitespace :ensure t :bind (&amp;#34;C-c C-c&amp;#34; . my:cleanup-for-spaces) :hook (prog-mode-hook . my:enable-trailing-mode) :custom (show-trailing-whitespace . nil) :config (defun my:enable-trailing-mode () &amp;#34;Show tail whitespace.&amp;#34; (setq show-trailing-whitespace t)) (defun my:cleanup-for-spaces () &amp;#34;Remove contiguous line breaks at end of line + end of file.&amp;#34; (interactive) (delete-trailing-whitespace) (save-excursion (save-restriction (widen) (goto-char (point-max)) (delete-blank-lines))))) </description>
    </item>
    
    <item>
      <title>7.. calendar</title>
      <link>https://minorugh.github.io/.emacs.d/display/calendar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/calendar/</guid>
      <description>6.4. [japanese-holidays] カレンダーをカラフルにする ビルドインの holidays と japanese-holidays.elを使います。土日祝日に色を着けます。土曜日と日曜祝日で異なる配色にできます。
(leaf calendar :leaf-defer t :bind ((&amp;#34;&amp;lt;f7&amp;gt;&amp;#34; . calendar) (:calendar-mode-map (&amp;#34;&amp;lt;f7&amp;gt;&amp;#34; . calendar-exit))) :config (leaf japanese-holidays :ensure t :require t :hook ((calendar-today-visible-hook . japanese-holiday-mark-weekend) (calendar-today-invisible-hook . japanese-holiday-mark-weekend) (calendar-today-visible-hook . calendar-mark-today)) :config (setq calendar-holidays (append japanese-holidays holiday-local-holidays holiday-other-holidays)) (setq calendar-mark-holidays-flag t))) </description>
    </item>
    
    <item>
      <title>7.. calendar</title>
      <link>https://minorugh.github.io/.emacs.d/display/prescient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/prescient/</guid>
      <description>6.13. [prescient.el] リスト項目の並び替えとイニシャル入力機能（ivy and company） コマンド履歴を保存、コマンドのイニシャル入力を可能にする。
(leaf prescient :ensure t :hook (after-init-hook . prescient-persist-mode) :custom `((prescient-aggressive-file-save . t) (prescient-save-file . &amp;quot;~/.emacs.d/tmp/prescient-save&amp;quot;)) :init (with-eval-after-load &#39;prescient (leaf ivy-prescient :ensure t :global-minor-mode t) (leaf company-prescient :ensure t :global-minor-mode t))) </description>
    </item>
    
    <item>
      <title>7.. diff-hl</title>
      <link>https://minorugh.github.io/.emacs.d/display/diff-hl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/diff-hl/</guid>
      <description>6.3. [diff-hl] 編集差分をフレーム端で視覚化 編集差分の視覚化は、元々 git-gutter が提供している機能です。しかし有効にするとフレームの幅が若干広がってしまうなどの不便さがあったので diff-hl に乗り換えました。
(leaf diff-hl :ensure t :hook ((after-init-hook . global-diff-hl-mode) (after-init-hook . diff-hl-margin-mode))) </description>
    </item>
    
    <item>
      <title>7.. imenu-list</title>
      <link>https://minorugh.github.io/.emacs.d/display/imenu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/imenu/</guid>
      <description>6.12. [imenu-list] サイドバー的にファイル内容の目次要素を表示 @takaxpさんの改良版/imenu-list を使ってます。
(leaf imenu-list :ensure t :bind (&amp;quot;&amp;lt;f2&amp;gt;&amp;quot; . imenu-list-smart-toggle) :custom `((imenu-list-size . 30) (imenu-list-position . &#39;left) (imenu-list-focus-after-activation . t))) counsel-css.el を導入すると便利です。
(leaf counsel-css :ensure t :hook (css-mode-hook . counsel-css-imenu-setup)) </description>
    </item>
    
    <item>
      <title>7.. toggle-fullscreen</title>
      <link>https://minorugh.github.io/.emacs.d/display/toggle-fullscreen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/toggle-fullscreen/</guid>
      <description>(global-set-key &amp;#34;&amp;lt;f11&amp;gt;&amp;#34; &amp;#39;toggle-fullscreen&amp;#39;) </description>
    </item>
    
    <item>
      <title>7.. which-key</title>
      <link>https://minorugh.github.io/.emacs.d/display/which-key/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/which-key/</guid>
      <description>[which-key] キーバインドの選択肢をポップアップする guide-key.el の後発、ディスパッチャが見やすく直感的でとても使いやすい。
(leaf which-key :ensure t :hook (after-init-hook . which-key-mode) :custom (which-key-max-description-length . 40)) </description>
    </item>
    
    <item>
      <title>display_01</title>
      <link>https://minorugh.github.io/.emacs.d/display/display_01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/display_01/</guid>
      <description>5. 編集サポート / 入力補助 ファイル編集や入力補助の設定をまとめている。
5.1. 矩形編集/連番入力 24.4 からは、rectangle-mark-mode が使えるようになり C-x SPC を押下すると矩形モードに入り直感的に矩形選択ができる。
標準の rect.el に以下の機能が実装されている。
|矩形切り取り|	C-x r k | |矩形削除	| C-x r d | |矩形貼り付け|	C-x r y | |矩形先頭に文字を挿入|	C-x r t | |矩形を空白に変換する|	C-x r c |
5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。
(leaf markdown-mode :ensure t :mode (&amp;#34;\\.md\\&amp;#39;&amp;#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-emacs-lisp-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。
https://github.com/shime/emacs-livedown
npmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。
$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。</description>
    </item>
    
  </channel>
</rss>
