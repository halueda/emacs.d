<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>minoru&#39;s Emacs Configuration</title>
    <link>https://minorugh.github.io/.emacs.d/</link>
    <description>Recent content on minoru&#39;s Emacs Configuration</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language><atom:link href="https://minorugh.github.io/.emacs.d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.1. eary-init.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/eary-init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/eary-init/</guid>
      <description>early-init.el は、Emacs27から導入されました。 https://github.com/minorugh/dotfiles/blob/main/.emacs.d/early-init.el  init.el でパッケージシステムやGUIの初期化が実行される前にロードされるので、UI関係や package-enable-at-startup のようなパッケージ初期化プロセスに影響を与える変数をカスタマイズできます。
GCを減らす GC の閾値を最大にしておくことで GC を実質止めることができます。とりあえず書いておけば速くなる系なのでおすすめです。
;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) eary-init.el の先頭に書くことが重要です。
Package の初期化を抑制する Emacs27では、(package-initialize) が 2回実行されます。 (1回は init ファイルの評価中に、もう 1回は Emacs が initファイルの読み取りを終了した後に)。
1回目を抑制するために以下を eary-init.el に記述することで初期化が少し早くなります。
;; For slightly faster startup (setq package-enable-at-startup nil) 常に最新のバイトコードをロードする ;; Always load newest byte code (setq load-prefer-newer t) フレームのサイズ変更を禁止する ;; Inhibit resizing frame (setq frame-inhibit-implied-resize t) これらを無効にする方が速い (初期化される前) ;; Faster to disable these here (before they&amp;#39;ve been initialized) (push &amp;#39;(fullscreen .</description>
    </item>
    
    <item>
      <title>1.2. Magic File Name を一時的に無効にする</title>
      <link>https://minorugh.github.io/.emacs.d/startup/magick-file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/magick-file/</guid>
      <description>Magic File Name を一時的に無効にすることで、起動時間を短縮できます。 GC設定とともに設定ファイル読み込み後に正常値に戻します。  ;; Speed up startup (unless (or (daemonp) noninteractive init-file-debug) (let ((old-file-name-handler-alist file-name-handler-alist)) (setq file-name-handler-alist nil) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover file name handlers.&amp;#34; (setq file-name-handler-alist (delete-dups (append file-name-handler-alist old-file-name-handler-alist))))))) ;; Defer garbage collection further back in the startup process (setq gc-cons-threshold most-positive-fixnum) (add-hook &amp;#39;emacs-startup-hook (lambda () &amp;#34;Recover GC values after startup.&amp;#34; (setq gc-cons-threshold 800000))) ※ init.el の先頭に書きます。</description>
    </item>
    
    <item>
      <title>1.3. leaf.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/leaf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/leaf/</guid>
      <description>これまで use-pacage.el を使っていましたが、 @conao3 さんの開発された leaf.el に触発されて全面的に書き直しました。
 Emacs入門から始めるleaf.el入門  (eval-and-compile (customize-set-variable &amp;#39;package-archives &amp;#39;((&amp;#34;org&amp;#34; . &amp;#34;https://orgmode.org/elpa/&amp;#34;) (&amp;#34;melpa&amp;#34; . &amp;#34;https://melpa.org/packages/&amp;#34;) (&amp;#34;gnu&amp;#34; . &amp;#34;https://elpa.gnu.org/packages/&amp;#34;))) (package-initialize) (unless (package-installed-p &amp;#39;leaf) (package-refresh-contents) (package-install &amp;#39;leaf)) (leaf leaf-keywords :ensure t :init (leaf hydra :ensure t) (leaf el-get :ensure t) :config (leaf-keywords-init))) </description>
    </item>
    
    <item>
      <title>1.4. init-loader.el を使う</title>
      <link>https://minorugh.github.io/.emacs.d/startup/init-loader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/init-loader/</guid>
      <description> emacs-jp/init-loader:Loader of configuration files.  設定ファイル群のローダーです。 指定されたディレクトリから構成ファイルをロードします。これにより、構成を分類して複数のファイルに分けることができます。
init-loader には、エラーが出た設定ファイルは読み込まれない&amp;hellip;という特徴があり原因究明がしやすくなるというメリットがある。またログの出力機能を備えていることもメリットとして挙げられる。
起動時間が犠牲になるということで敬遠される向きもあるが微々たるもので、恩恵のほうが遥かに大きい。
(leaf init-loader :ensure t :config (custom-set-variables &amp;#39;(init-loader-show-log-after-init &amp;#39;error-only)) (init-loader-load)) </description>
    </item>
    
    <item>
      <title>1.5. 最小限の emacs起動設定</title>
      <link>https://minorugh.github.io/.emacs.d/startup/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/startup/test/</guid>
      <description>最小限の emacs を起動させるための設定です。  test.el は、 新しいパッケージを試したり設定をテストしたり、エラー等で Emacsが起動しない場合などに使用します。
以下を .zshrc または .coderc に記述し反映させたのち、シェルから eq と入力することで起動することがでます。
alias eq = &amp;#39;emacs -q -l ~/.emacs.d/test.el&amp;#39; ファイルの PATH は、ご自分の環境に応じて修正が必要です。</description>
    </item>
    
    <item>
      <title>2.1. 言語と文字コード</title>
      <link>https://minorugh.github.io/.emacs.d/core/encode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/encode/</guid>
      <description>シンプルにこれだけです。
(set-language-environment &amp;#34;Japanese&amp;#34;) (prefer-coding-system &amp;#39;utf-8) </description>
    </item>
    
    <item>
      <title>2.2. フォント設定</title>
      <link>https://minorugh.github.io/.emacs.d/core/font/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/font/</guid>
      <description>GUI / CUI 共通で Cica を使っています。  Cicaフォントは、Hack、DejaVu Sans Mono、Rounded Mgen+、Noto Emoji等のフォントを組み合わせて調整をした、日本語の等幅フォントです。
 プログラミング用日本語等幅フォント Cica Think Pad を2台使っていますので、環境を取得して設定を変えています。  フォントの設定  メイン機（Thinkpad E590）とサブ機（Thinkpad X250）とでそれぞれに適した値を決めています。  (add-to-list &amp;#39;default-frame-alist &amp;#39;(font . &amp;#34;Cica-18&amp;#34;)) ;; for sub-machine (when (string-match &amp;#34;x250&amp;#34; (code-command-to-string &amp;#34;uname -n&amp;#34;)) (add-to-list &amp;#39;default-frame-alist &amp;#39;(font . &amp;#34;Cica-15&amp;#34;))) Cicaフォントのインストール   Linux 環境でのインストールの方法です。
  オフィシャルページにある最新の Cica v5.03 は、 page-break-lines で表示が乱れます。
   Cica-v5.0.1のダウンロードページから、 (Cica-v5.0.1.zip) をダウンロードします。 上記サイトの存続は怪しいので自分のサイトにも置いておきます。 Cica-v5.0.1.zip  zipファイルを展開します。  $ unzip Cica-v5.</description>
    </item>
    
    <item>
      <title>2.3. 日本語入力の設定</title>
      <link>https://minorugh.github.io/.emacs.d/core/mozc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/mozc/</guid>
      <description>Debian11 にインストールした Emacs上で emacs-mozc を使っています。 debian でのインストール手順は以下の通り。  $ sudo apt-get install fcitx-mozc emacs-mozc Emacsをソースからビルドするときに --without-xim しなかったので、インライン XIMでも日本語入力ができてしまいます。 特に使い分けする必要もなく紛らわしいので .Xresources で XIM無効化の設定をしました。
! ~/.Xresources ! Emacs XIMを無効化 Emacs*useXIM: false 句読点などを入力したとき、わざわざ mozcに変換してもらう必要はないので以下を設定しておくことでワンアクションスピーディーになります。
(leaf mozc :ensure t :bind ((&amp;#34;&amp;lt;hiragana-katakana&amp;gt;&amp;#34; . toggle-input-method) (:mozc-mode-map (&amp;#34;,&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;、&amp;#34;))) (&amp;#34;.&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;。&amp;#34;))) (&amp;#34;?&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;？&amp;#34;))) (&amp;#34;!&amp;#34; . (lambda () (interactive) (mozc-insert-str &amp;#34;！&amp;#34;))))) :custom `((default-input-method .</description>
    </item>
    
    <item>
      <title>2.4. emacsclient を使う</title>
      <link>https://minorugh.github.io/.emacs.d/core/server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/server/</guid>
      <description>shell-command で emacsclient をよく使うので、Emacs起動時に server を起動させています。 重複起動させない設定です。  ;; Server start for emacs-client (leaf server :require t :config (unless (server-running-p) (server-start))) Linux の起動時に Emacsを最小化起動させる 起動オプションに --iconic を付すことで最小化起動します。
MENUから「セッションと起動」を立ち上げて「自動開始アプリケーション」に以下を設定すといいです。
$ emacs --iconic Emacsから最小化するのは、C-z: suspend-frame です。</description>
    </item>
    
    <item>
      <title>2.5. 設定をシェルから継承する</title>
      <link>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/exec-path-from-shell/</guid>
      <description> purcell/exec-path-from-shell: Make Emacs use the $PATH set up by the user&amp;rsquo;s shell  外部プログラムのサポートを得て動くパッケージは、設定の過程で「プログラムが見つからない」と怒られることがしばしばあります。 exec-path-from-shell は、シェルに設定した PATH の情報を継承して exec-path や PATH を設定してくれます。自分は、shell-commad や compile-command をよく使うので必須のパッケージです。
(leaf exec-path-from-shell :ensure t :when (memq window-system &amp;#39;(mac ns x)) :hook (after-init-hook . exec-path-from-shell-initialize) :custom (exec-path-from-shell-check-startup-files . nil)) </description>
    </item>
    
    <item>
      <title>2.6. 同じバッファ名が開かれた場合に区別する</title>
      <link>https://minorugh.github.io/.emacs.d/core/uniquify/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/uniquify/</guid>
      <description>ビルトインの uniquify を使います。
(setq uniquify-buffer-name-style &amp;#39;post-forward-angle-brackets) </description>
    </item>
    
    <item>
      <title>2.7. グローバルキーバインド</title>
      <link>https://minorugh.github.io/.emacs.d/core/global-keybind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/core/global-keybind/</guid>
      <description>グローバルキーバインドを自分好みにカスタマイズしました。 前準備として以下を設定しておきます。
 クリップボードを使えるようにする  ;; Use the X11 clipboard (setq select-enable-clipboard t)  マウスで選択した領域を自動コピー マウスで選択すると，勝手にペーストボードにデータが流れます．  (setq mouse-drag-copy-region t) グローバルキーバインドをカスタマイズする  C-w は、kill-ring-save に割り当てられたものですが、region 選択されていないときは、一行削除になるようにカスタマイズしてます。 C-x k の kill-buffer は、yes/no 確認されるのが煩わしいので、確認なしの kill-this-buffer を愛用しています。  ;; Change global key bind (leaf cus-global-keybind :bind ((&amp;#34;M-w&amp;#34; . clipboard-kill-ring-save) (&amp;#34;C-w&amp;#34; . my:kill-whole-line-or-region) (&amp;#34;s-c&amp;#34; . clipboard-kill-ring-save) (&amp;#34;s-v&amp;#34; . clipboard-yank) (&amp;#34;M-/&amp;#34; . kill-this-buffer))) ;; Overwrite `C-w&amp;#39; to the whole-line-or-region (defun my:kill-whole-line-or-region () &amp;#34;If the region is active, to kill region.</description>
    </item>
    
    <item>
      <title>3.1. バッファーの先頭と最終行への移動を簡単にする</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/sequential-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/sequential-command/</guid>
      <description>sequential-command は、標準の C-a C-e を拡張し、バッファーの先頭と最終行への移動を簡単にしてくれます。
 https://github.com/HKey/sequential-command C-a を連続で打つことで行頭→ファイルの先頭→元の位置とカーソルが移動 C-e を連続で打つことで行末→ファイルの最終行→元の位置とカーソルが移動  地味ながら一度使うと便利すぎて止められません。
MELPAから Installできますが、私は HKey氏の改良版を el-get でインストールしました。
(leaf sequential-command :doc &amp;#34;https://bre.is/6Xu4fQs6&amp;#34; :el-get HKey/sequential-command :config (leaf sequential-command-config :hook (emacs-startup-hook . sequential-command-setup-keys))) </description>
    </item>
    
    <item>
      <title>3.2. ウインドウ間のカーソル移動</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/other-window-or-sprit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/other-window-or-sprit/</guid>
      <description> C-c o でもいいですが，ワンアクションで移動できるほうが楽なので、次のように双方向で使えるように設定しています． 画面分割されていないときは、左右分割して follow-mode dimmer-mode も ON にしています。（詳細後述）  (defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (bind-key &amp;#34;C-q&amp;#34; &amp;#39;other-window-or-split) </description>
    </item>
    
    <item>
      <title>3.3. 括弧の先頭と最後へ交互にポイント移動します。</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/jump-brace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/jump-brace/</guid>
      <description>括弧の先頭と最後へ交互にポイント移動します。
 C-M-SPC (mark-sexp) は，カーソル位置から順方向に選択． C-M-U (backward-up-list) は，一つ外のカッコの先頭にポイントを移す．  ただ、上記標準機能はなにげに使いにくいので my:jump-brace を定義しました。 括弧の先頭と最後へ交互にポイント移動します。
(defun my:jump-brace () &amp;#34;Jump to the corresponding parenthesis.&amp;#34; (interactive) (let ((c (following-char)) (p (preceding-char))) (if (eq (char-syntax c) 40) (forward-list) (if (eq (char-syntax p) 41) (backward-list) (backward-up-list))))) (bind-key &amp;#34;C-M-9&amp;#34; &amp;#39;my:jump-brace) </description>
    </item>
    
    <item>
      <title>3.4. 直前の編集ポイントと現在のポイントとを行き来する。</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/mark-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/mark-command/</guid>
      <description> C-x C-x は、直前の編集ポイントと現在のポイントとを行き来できる設定です。  (defun my:exchange-point-and-mark () &amp;#34;No mark active `exchange-point-and-mark&amp;#39;.&amp;#34; (interactive) (exchange-point-and-mark) (deactivate-mark))	(bind-key &amp;#34;C-x C-x&amp;#34; &amp;#39;my:exchange-point-and-mark) *標準機能の C-u C-SPC でマーク箇所を辿れるようになります。 (setq set-mark-command-repeat-pop t) (setq mark-ring-max 32) (setq global-mark-ring-max 64) </description>
    </item>
    
    <item>
      <title>3.5. カーソル位置を起点に選択範囲を賢く広げる</title>
      <link>https://minorugh.github.io/.emacs.d/cursor/expand-region/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/cursor/expand-region/</guid>
      <description>expand-region.el は、カーソル位置を起点として前後に選択範囲を広げてくれます。
2回以上呼ぶとその回数だけ賢く選択範囲が広がりますが、2回目以降は設定したキーバインドの最後の一文字を連打すれば OKです。その場合、選択範囲を狭める時は - を押し， 0 を押せばリセットされます。
(leaf expand-region :ensure t :bind (&amp;#34;C-@&amp;#34; . er/expand-region)) </description>
    </item>
    
    <item>
      <title>4.1. カーソル行に色をつける</title>
      <link>https://minorugh.github.io/.emacs.d/higlight/hl-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/higlight/hl-line/</guid>
      <description>  ビルトインの hl-line を使います.
  http://murakan.cocolog-nifty.com/blog/2009/01/emacs-tips-1d45.html
  https://www.emacswiki.org/emacs/highlight-current-line.el
  機能別にhl-line のon/off や色を変えたりという設定もできますが、私の場合は、シンプルに global 設定して色は theme に依存というスタイルです。
(global-hl-line-mode 1) </description>
    </item>
    
    <item>
      <title>all-the-icons</title>
      <link>https://minorugh.github.io/.emacs.d/ui/all-the-icons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/all-the-icons/</guid>
      <description>all-the-icons.el を使うとバッファ内やモードライン、ミニバッファでアイコンを表示できるようになります。
 domtronn/all-the-icons.el: A utility package to collect various Icon Fonts and propertize them within Emacs.  初めて使うときはパッケージを使えるようにした後、M-x all-the-icons-install-fonts すると自動的にフォントがインストールされます。以下の設定では自動化しています。
(leaf display-line-numbers :hook ((after-init-hook . global-display-line-numbers-mode) (lisp-interaction-mode-hook dired-mode-hook). my:disable-modes) :bind (&amp;#34;&amp;lt;f9&amp;gt;&amp;#34; . display-line-numbers-mode) :custom (display-line-numbers-width-start . t) :init (defun my:disable-modes () &amp;#34;Disable modes in scrtch buffer.&amp;#34; (interactive) (display-line-numbers-mode 0) (flymake-mode 0))) all-the-icons-dired dired でファイルのアイコンを表示します。
 Emacs27以降、MELPA版は白色にしか表示されないので jtbm37/all-the-icons-dired をel-getでインストールしています。  (leaf all-the-icons-dired :el-get jtbm37/all-the-icons-dired :after doom-modeline :hook (dired-mode-hook . all-the-icons-dired-mode)) all-the-icons-ivy-rich ivy-mode でアイコン表示をします。</description>
    </item>
    
    <item>
      <title>display_01</title>
      <link>https://minorugh.github.io/.emacs.d/display/display_01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/display/display_01/</guid>
      <description>5. 編集サポート / 入力補助 ファイル編集や入力補助の設定をまとめている。
5.1. 矩形編集/連番入力 24.4 からは、rectangle-mark-mode が使えるようになり C-x SPC を押下すると矩形モードに入り直感的に矩形選択ができる。
標準の rect.el に以下の機能が実装されている。
|矩形切り取り|	C-x r k | |矩形削除	| C-x r d | |矩形貼り付け|	C-x r y | |矩形先頭に文字を挿入|	C-x r t | |矩形を空白に変換する|	C-x r c |
5.2. markdownモード markdown-mode.el は、Markdown形式のテキストを編集するための主要なモードです。
(leaf markdown-mode :ensure t :mode (&amp;#34;\\.md\\&amp;#39;&amp;#34;) :custom `((markdown-italic-underscore . t) (markdown-asymmetric-header . t) (markdown-fontify-emacs-lisp-blocks-natively . t)) markdownファイルのプレビューには、emacs-livedown を使っています。 記事を書きながらライブでプレビュー出来るすぐれものです。
https://github.com/shime/emacs-livedown
npmがインストールされたnodeが入っていことを確認してからlivedownをインストールします。
$ npm install -g livedown 次にEmacsの設定を書きます。 MELPAにはないのでel-get でインストールします。</description>
    </item>
    
    <item>
      <title>doom-modeline</title>
      <link>https://minorugh.github.io/.emacs.d/ui/doom-modeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/doom-modeline/</guid>
      <description>(leaf doom-modeline :ensure t :hook (after-init-hook . doom-modeline-mode) :custom (doom-modeline-icon . t) (doom-modeline-major-mode-icon . nil) (doom-modeline-minor-modes . nil) :config (line-number-mode 0) (column-number-mode 0) (doom-modeline-def-modeline &amp;#39;main &amp;#39;(bar window-number matches buffer-info remote-host buffer-position parrot selection-info) &amp;#39;(misc-info persp-name lsp github debug minor-modes input-method major-mode process vcs checker)) :init (leaf nyan-mode :ensure t :config (nyan-mode 1) (nyan-start-animation))) </description>
    </item>
    
    <item>
      <title>doom-thmes</title>
      <link>https://minorugh.github.io/.emacs.d/ui/doom-themes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/ui/doom-themes/</guid>
      <description>(leaf doom-themes :ensure t :hook (after-init-hook . (lambda () (load-theme &#39;doom-dracula t))) :custom (doom-themes-enable-italic . nil) (doom-themes-enable-bold . nil) :config (doom-themes-neotree-config) (doom-themes-org-config)) </description>
    </item>
    
    <item>
      <title>現在のバッファ以外の輝度を落とす</title>
      <link>https://minorugh.github.io/.emacs.d/buffer/dimmer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/buffer/dimmer/</guid>
      <description>dimmer.el は、現在のバッファ以外の輝度を落とす機能を実現するためのパッケージです。  takaxp.github.io の設定をそのままパクリました。 on/off できるのが快適です。
(leaf dimmer :ensure t :chord (&amp;#34;..&amp;#34; . my:toggle-dimmer) :config (defvar my:dimmer-mode 1) (setq dimmer-buffer-exclusion-regexps &amp;#39;(&amp;#34;^ \\*which-key\\|^ \\*LV\\|^ \\*.*posframe.*buffer.*\\*$&amp;#34;)) (setq dimmer-fraction 0.6) (defun my:toggle-dimmer () (interactive) (unless (one-window-p) (if (setq my:dimmer-mode (not my:dimmer-mode)) (dimmer-on) (dimmer-off)))) (defun dimmer-off () (dimmer-process-all) (dimmer-mode -1)) (defun dimmer-on () (when my:dimmer-mode (dimmer-mode 1) (dimmer-process-all)))) Sprit-window と連携させる dimmer-mode を global に設定すると多くのシーンでDisable対策の設定が必要になり面倒です。
下記の通り発想転換すれば呪縛から逃れることができます。
 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((&amp;#34;C-q&amp;#34; .</description>
    </item>
    
    <item>
      <title>画面分割とdimmerを連携させる</title>
      <link>https://minorugh.github.io/.emacs.d/buffer/sprit-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://minorugh.github.io/.emacs.d/buffer/sprit-window/</guid>
      <description>dimmer-mode との連携をさせるために、デフォルトのキーバインドをカスタマイズします。
 同じバッファーを分割したときは、follow-mode にする。 画面分割したときは、dimmer-mode-on にする。 画面分割を閉じたときは、dimmer-mode-off にする。  (leaf *sprit-window-configurations :bind ((&amp;#34;C-q&amp;#34; . other-window-or-split) (&amp;#34;C-x 2&amp;#34; . my:split-window-below) (&amp;#34;C-x 1&amp;#34; . my:delete-other-windows) (&amp;#34;C-x 0&amp;#34; . my:delete-window) (&amp;#34;&amp;lt;C-return&amp;gt;&amp;#34; . window-swap-states)) :init (defun other-window-or-split () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (when (one-window-p) (split-window-horizontally) (follow-mode 1) (dimmer-mode 1)) (other-window 1)) (defun my:split-window-below () &amp;#34;With turn on dimmer.&amp;#34; (interactive) (split-window-below) (follow-mode 1) (dimmer-mode 1)) (defun my:delete-window () &amp;#34;With turn off dimmer.&amp;#34; (interactive) (delete-window) (follow-mode -1) (dimmer-mode -1)) (defun my:delete-other-windows () &amp;#34;With turn off dimmer.</description>
    </item>
    
  </channel>
</rss>
